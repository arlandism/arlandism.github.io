---
layout: article
title: 'Template Vs Strategy: Part II - Strategy Wins'
date: '2013-10-19T07:40:00.000-07:00'
author: aml
tags: 
modified_time: '2013-10-19T07:40:46.309-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1915005412981327388
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/10/template-vs-strategy-part-ii-strategy.html
---

I was recently dealing with a Template vs. Strategy pattern decision and I opted for the Template pattern. The code looked something like this:<br /><br /><br /><pre class="brush:java" name="code">public class TemplatePatternImp {<br /><br />  public FileResponse response(Request request){<br />      if (request.requestedResource.endsWith("txt"){<br />        return new TextFileResponse(request);<br />      } <br />  }<br /><br />}<br /></pre><br />The file responses only varied by content type, so I created an abstract base class called "FileResponse" that encapsulated the algorithm for retrieving a file's body. The subclasses only initialized their content types and they were good to go. This way, I could create a new subclass whenever I wanted to support a new kind of file. The other option here was to make "FileResponse" a concrete class and just pass in a content type in the constructor.<br /><br />As the number of files I supported in the server grew, so did this conditional and the number of subclasses. The primary reason I chose the Template pattern in this case was because there was so little code involved with creating a new subclass that I thought splitting it up into separate files would result in more readable code, assuming the reader realized that each subclass just had their own content type.<br /><br />My mentor and I paired on the problem yesterday, and came up with a more readable, and less complex solution.<br /><br /><br /><pre class="brush:java" name="code"><br />public class StrategyPatternImp {<br /><br />  private Map<String, String> extensionToContentType;<br />  extensionToContentType.put("new extension", "new content type");<br />}<br /><br />  public FileResponse response(Request request){<br />    String extension = findExtension(request.requestedResource());<br />    return new FileResponse(extensionToContentType.get(extension));<br />  }<br /><br />  public String findExtension(String requestedResource){<br />     Integer index requestedResource.lastIndexOf(".") + 1;<br />     Integer end requestedResource.length();<br />     return requestedResource.substring(index, end);<br />  }<br /></pre><br /><br />In an <a href="http://immutablearlandis.blogspot.com/2013/08/template-pattern-vs-strategy-pattern.html">earlier post</a>, I mentioned that I would always go after the Strategy pattern; I should've stuck to my guns.
