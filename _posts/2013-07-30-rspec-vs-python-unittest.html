---
layout: post
title: RSpec vs. Python unittest
date: '2013-07-30T12:09:00.000-07:00'
author: aml
tags: 
modified_time: '2013-07-30T12:09:16.544-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7697019995227709785
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/07/rspec-vs-python-unittest.html
---

I got to see some of RSpec's true power released today. It was really mind-blowing because I've been using Python's unittest module which doesn't have nearly the same capabilities as RSpec. For instance, if I wanted to mock some class' methods in Python I would have to write a mock with those same methods that return what I wanted. This may look something like this:<br /><br /><br /><pre class="brush:python" name="code">import unittest<br /><br />class MyClassTests(unittest.TestCase):<br /><br />    def test_my_class_calls_other_class(self):<br />        other_class = MockOtherClass()<br />        my_class = MyClass(other_class)<br />        self.assertEqual("I'm the other class", my_class.do_something())<br /><br />class MyClass(object):<br /><br />    def __init__(self,other_class):<br />        self.other_class = other_class<br /><br />    def do_something(self):<br />        self.other_class_obj.do()<br /><br />class MockOtherClass(object):<br /><br />    def do(self):<br />        return "I'm the other class"<br /></pre><br />You have to build up this elaborate test-dance just to assert that MyClass actually calls the other class in its implementation. This is good and bad. It's bad because your tests are lengthy and complex, and therefore less likely to be read. It's good because it can force you to do dependency injection and point out design smells in your code. If you need some elaborate mock to test something simple then you may be missing a level of abstraction.<br /><br />RSpec provides some powerful mechanisms for similar testing situations.<br /><br /><pre class="brush:ruby" name="code">describe "MyClass" do<br />  <br />  it "should call otherclass' do"<br />    OtherClass.stub(:do).and_return("I'm the other class")<br />    MyClass.new.do_something.should == "I'm the other class"<br />  end<br />end<br /></pre><br />In the RSpec test, I didn't have to do any dependency injection. I could just stub out any call to the "do" method of OtherClass and make it return what I wanted. Once again, this is both good and bad. There's obviously less overheard with a test like this, but you aren't forced to smell your bad design decisions. There are times when you need to test dependencies without injecting them though. In situations like these, RSpec definitely has the upper-hand.