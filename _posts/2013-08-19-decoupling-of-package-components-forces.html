---
layout: post
title: Decoupling of Package Components Forces Decoupling of Design
date: '2013-08-19T20:06:00.004-07:00'
author: aml
tags: 
modified_time: '2013-08-19T20:06:54.829-07:00'
thumbnail: http://2.bp.blogspot.com/-WJrQwzAimlk/UhLc1tWQOfI/AAAAAAAAAJ4/nYzHf3KsMKc/s72-c/packages.jpg
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-8046573706875304813
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/decoupling-of-package-components-forces.html
---

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><span style="margin-left: auto; margin-right: auto;"><a href="http://articles.philly.com/2012-03-25/news/31236866_1_parcels-and-documents-ups-cargo-plane-ups-jet" target="_blank"><img border="0" height="185" src="http://2.bp.blogspot.com/-WJrQwzAimlk/UhLc1tWQOfI/AAAAAAAAAJ4/nYzHf3KsMKc/s320/packages.jpg" width="320" /></a></span></td></tr><tr><td class="tr-caption" style="text-align: center;"><a href="http://articles.philly.com/2012-03-25/news/31236866_1_parcels-and-documents-ups-cargo-plane-ups-jet" target="_blank">Image from&nbsp;articles.philly.com</a></td></tr></tbody></table><br /><br />I've gotten to the Package Components chapter of <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" target="_blank">PPP</a> and it sheds light on something I had been pondering over. A couple of weeks ago, I turned my large <a href="https://github.com/arlandism/tic_tac_toe" target="_blank">Tic Tac Toe application</a> into a series of modules. After the structural refactor all my tests began to break. In order to access the files under test from the new modules, the tests needed to explicitly import those files by referencing the modules they were in. This simple convention forced me to think hard.<br /><br />Tests with imports like this:<br /><br /><br /><pre class="brush:python" name="code">import unittest<br />from game import *<br />from base_board import BaseBoard<br />from ai import ImpossibleAI<br />from test_utils import FakePrinter, MockUserInput, MockPlayer<br />from player import HumanPlayer<br />from playerinput import InputValidator<br /></pre><br />turned into.... <br /><br /><pre class="brush:python">import unittest<br />from game.game import *<br />from game.base_board import BaseBoard<br />from game.ai import ImpossibleAI<br />from test_utils import FakePrinter, MockUserInput, MockPlayer<br />from game.player import HumanPlayer<br />from io.playerinput import InputValidator<br /></pre><br />Can you smell the poor design? There's tons of evidence that this test code is too coupled to other classes and packages.<br /><br />First of all, we're importing from the IO package and this file is testing the Game class. We shouldn't need IO stuff to test the Game class! And what's all that other stuff we're importing? I mean sure they're in the game package, but it seems glaringly obvious that we shouldn't need so many outside classes to test our one class. Granted, we may need to pass some stuff in to the constructor of the Game class and want to reduce our reliance on mocks. That's fair, but I think this is evidence of something much worse.<br /><br /><b>Solutions</b><br /><b><br /></b>I think the simplest solution here is to refactor the tests in such a way that I can maintain confidence and decrease coupling. If that can't be done then I think a design overhaul is in order. As I work on extending the Tic Tac Toe application to the web it's becoming more and more evident that the core of the application relies too much on the command line. In his <a href="http://cleancoders.com/" target="_blank">Clean Coder video series</a>, <a href="https://twitter.com/unclebobmartin" target="_blank">Uncle Bob</a> talks at great length about the dangers of applications too tightly coupled to their user interfaces. I'm really feeling the pain of these poor design decisions now. I think that had I designed the Tic Tac Toe module in such a way that it was completely decoupled, and then extended it to the command line, that the current web version of it I'm working on would be much simpler.<br /><br /><b>Summary</b><br /><b><br /></b>The core of your application should revolve around your application's functionality. It seems that the <a href="http://www.objectmentor.com/resources/articles/srp.pdf" target="_blank">Single Responsibility Principle</a> extends all the way up the pyramid - from low-level functions to package components. The method of delivery for your application, whether it be the command-line, the web, the desktop, or a mobile device, should be an afterthought. You should be able to access your application's API and make it work through any of these mediums. If your applications are designed in this manner, then I think you'll find extending them to other delivery mechanisms will be much less difficult.