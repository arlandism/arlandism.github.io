---
layout: article
title: Unhappy Testing
date: '2013-09-03T11:58:00.000-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-09-03T11:58:31.841-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-3547335585096987068
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/unhappy-testing.html
---

I had to make a difficult decision today and I'm hoping that reflecting on it will provide some insight that I haven't grasped yet.<br /><br />I was forced to write a test that I was unhappy with. The reason that I'm unhappy with the test is because it's fragile and somewhat misleading.<br /><br />Here's the code:<br /><br /><pre class="brush:ruby" name="code">it "doesn't call the service if moves have been made" do<br />      rack_mock_session.cookie_jar["first_player"] = "computer"<br />      rack_mock_session.cookie_jar["4"] = "x"<br />      ai = double(:ai)<br />      AI.stub(:new).and_return(ai)<br />      ai.should_not_receive(:next_move)      <br />      get '/'<br />    end<br /></pre><br />Here's the complex problem that this test is trying to solve:<br /><br />There's a 'get index' route and a 'post move' route. During a standard execution of the application, users make moves that are handled by the 'post move' handler, which then invokes the AI. But, users have the option of selecting the AI to move first. In order to make the user experience smoother, all the user has to do is select the first player as the computer and they're redirected to the index where a computer move has already been made. In order for this to happen, the 'get index' route has to check if the first player is the computer and, if it is, call it before rendering the page. The problem occurs when the user goes to make a move. The 'post move' handler calls the service again, at which point the user is redirected to the index, and the service is called again! The AI gets to move twice. To stomp this behavior out, I had to write a check for empty boards. Now, if the first player is AI and the board is empty, then the AI will be called, otherwise the page will just be rendered as normal.<br /><br /><b>Back to the Test</b><br /><b><br /></b>The test basically says set the first player as "computer" and put a move on the board. Then, navigate to the index page and assert that the AI isn't called.<br />There are a couple reasons why I'm unhappy with this code:<br /><br /><ul><li>It's very coupled to the concept of cookies. My mentor and I had a discussion about not having the tests rely on the implementation of state in the application.</li><li>I'm starting not to like the idea of "should_receive" assertions. When you're trying to rapidly write a test, it's hard to keep track of what scope they execute in.</li><li>The test doesn't accurately reflect what would happen. In normal circumstances, a user would navigate to the configuration page and make a move. This goes back to the first problem; I want tests that rely on behavior versus implementation.</li></ul><div>Unfortunately, I wasn't able to write the test I would've been happy with because of the mistiness surrounding RSpec's "should_receive" and "should_not_receive" statements. The 'post move' handler should be calling the AI, while the 'get index' handler shouldn't be if the board's not empty. How do you get that behavior using "should_receive" and "should_not_receive"? If I commented out a "should_receive" assertion and just had "should_not_receive" then the tests would pass. Conversely, if I commented out the "should_not_receive" assertion and left in a "should_receive" then the tests would pass. This was confusing and made me rethink my testing strategy altogether. I want to reflect on this test and try to understand what it may be telling me about my design.</div>
