---
layout: post
title: Dojo Dashboard Architectural Overview
date: '2013-11-24T15:38:00.001-08:00'
author: aml
tags: 
modified_time: '2013-11-24T15:38:16.812-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-4619909846818883911
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/11/dojo-dashboard-architectural-overview.html
---

The Dojo Dashboard has an interesting architecture that I thought it'd be cool to write about. I haven't worked with enough systems to know whether or not it's a good architecture, but it works for its current use-cases and that's what matters.<br /><br /><b>Widgets</b><br /><b><br /></b>The core of the application revolves around the idea of widgets - autonomous pieces of functionality that can be added and removed at will. The widgets are small displays of data, usually retrieved by calling an external API; a couple of them are more involved.<br /><br />Let's talk about an example widget: "travis". The travis widget shows the passing and failing builds on internal projects by hitting the travis-ci API. Let's assume the travis widget doesn't already exist on the page. A user clicks the add-widget button in the lower-left corner of the screen. This opens a dialogue with a dropdown menu and a textarea. Upon selecting "travis", the textarea is populated with default text that corresponds to the Clojure data structure used to generate the widget. The travis widget doesn't require parameters so clicking submit will create the widget. Things get interesting now. On submission, the text from the textarea is passed to a parser that figures out what kind of widget was selected. There's a mapping of widget names to their corresponding "init" functions. The "init" function is called along with its corresponding parameters and the widget is generated.<br /><br /><b>Inits</b><br /><b><br /></b>The init functions are where all of the interesting things happen. When the init function is called it sends a request to the Clojure backend. The backend has its own API for sending requests to external APIs. A user says they want a travis widget, the frontend pings the backend, and the backend pings the travis API. The backend returns some data structure that the frontend code can understand at which point it's formatted and rendered.<br /><br />That's pretty much the core of the application. Though I've worked on it for about a week, I'm just now getting a complete grasp of it.<br /><br /><b>Pros</b><br /><b><br /></b><br /><ul><li>Adding a new widget is relatively easy. Once you get the core of the widget's functionality working on the backend then you just need to do some configuration, namely: a new route for the backend, adding the new widget to all of the mappings in the project, writing the widget's init function, and writing the rendering code. Everything sounds much harder than it is.</li></ul><ul><li>The project is in Clojure and Clojurescript which is just cool.</li></ul><br /><br /><b>Cons</b><br /><b><br /></b><br /><ul><li>It's somewhat difficult to figure out where stuff goes.&nbsp;</li></ul><ul><li>There's code that generates html on the frontend and the backend.&nbsp;</li></ul><ul><li>All of the widget's I've seen make use of core.async for the fetching of their backend request which adds another layer of complexity to wrap your head around.&nbsp;</li></ul><ul><li>It's difficult to determine what's tested and what isn't; there's view code with and without tests.</li></ul><br /><br /><b>Summary</b><br /><b><br /></b>Overall, I enjoy working on the project and hope to contribute to its well-being.