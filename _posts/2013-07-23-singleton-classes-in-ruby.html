---
layout: article
title: Singleton Classes in Ruby
date: '2013-07-23T08:23:00.001-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-07-23T08:24:30.523-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-6741319522021650918
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/07/singleton-classes-in-ruby.html
---

I'm almost done with the Ruby Koans and I've stumbled onto the Proxy object project. One of the things that I don't like about the Koans is the sort of ambiguity I feel when trying to complete a problem. I'm not sure if this ambiguity is a good thing or a bad thing, but it definitely makes me think harder about how to answer the question. Anyway, I cracked open <i><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/" target="_blank">Programming Ruby: The Pragmatic Programmer's Guide</a> </i>to find some answers. I came across a pretty interesting section on MetaClasses and <a href="http://www.devalot.com/articles/2008/09/ruby-singleton" target="_blank">Singleton Classes</a>. So, in an attempt to understand them more, I'll be doing a little BDD(Blog Driven-Development) to articulate how they work.<br /><br /><b>Singleton Classes</b><br /><b><br /></b>First of all, what is a metaclass? Well, Wikipedia can answer that question: "..a metaclass is a class whose instances are classes." I think what that means is that a metaclass is essentially a class factory. It spits out instances of itself, but these instances can spawn their own instances. Simple enough. To truly understand this significance I think it's worth digressing a bit to talk about Ruby's class model.<br /><br />Chapter 24 of <i>Programming Ruby</i>&nbsp;has a very simple description of how classes work in Ruby. All classes are instances of the class <b>Class</b>. We can outline this relationship in code.<br /><br /><br /><pre class="brush:ruby" name="code">class MyClass<br />end<br /><br />MyClass.is_a?(Object)<br />=&gt; true<br />MyClass.is_a?(Class)<br />=&gt; true<br />MyClass.instance_of?(Class)<br />=&gt; true<br /></pre><br />Notice how MyClass is simultaneously an Object, Class, and an instance of class <b>Class</b>.  When you call a method, the method has a receiver which defaults to self; self being a reference to the object invoking the method. The receiver goes up the inheritance hierarchy to find the method. If it reaches the top and still can't find the method then it calls method_missing, which will usually raise a NoMethodError. Back to singleton classes...<br /><br />One interesting thing that you can do in Ruby is define new methods for an object on the fly. Example:<br /><pre class="brush:ruby" name="code">class Bird<br />end<br />my_pet = Bird.new<br />my_pet.speak<br />=&gt; NoMethodError undefined method 'speak' for Bird<br />def my_pet.speak<br />  puts "Tweet"<br />end<br />my_pet.speak<br />=&gt; "Tweet"<br /></pre><br />What's actually happening here is that Ruby is creating a Singleton Class to hold this new "speak" method for us. So now when we call "speak" that Singleton Class is the default receiver. This Singleton Class is pretty much invisible. It can't be instantiated and tries to hide itself from view.<br /><br />So, when you define a class you're actually creating an instance of class <b>Class </b>and giving this instance its own methods and variables to work with; Ruby creates a Singleton class to hold this data the same way it created a Singleton class to hold our "speak" method. Cool, eh?<br /><br />My next post will talk about this topic some more.
