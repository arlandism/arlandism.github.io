---
layout: article
title: Hard TDD Questions - Commentary on Justin Searl's Post
date: '2014-02-04T13:56:00.003-08:00'
author: aml
tags: 
modified_time: '2014-02-04T13:56:58.514-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1869120297694795374
blogger_orig_url: https://immutablearlandis.blogspot.com/2014/02/hard-tdd-questions-commentary-on-justin.html
---

I found Uncle Bob's <a href="http://blog.8thlight.com/uncle-bob/2014/01/27/TheChickenOrTheRoad.html" target="_blank">latest blog post</a> really interesting! In it, he addresses the concerns expressed by Justin Searls in <a href="http://blog.testdouble.com/posts/2014-01-25-the-failures-of-intro-to-tdd.html" target="_blank">this blog post</a>. The things Justin mentions in his blog post really hit home for me as I've had to answer the exact same questions in my day-to-day development work. I thought it'd be fun to address Justin's concerns as well.<br /><ul><li>Encouraging Large Units. In this point, Justin mentions the difficulty in explaining to TDD newbies how to make steady progress toward a solution while making meaningful decompositions of the implementation code written to pass the tests. This is something I struggled with when I started with TDD. There's no end-all solution here and Justin is right that there are no explicit indicators in TDD telling you that it's time to decompose your solution but I think there are red flags. One example is when your tests are growing in complexity. If it starts getting difficult to read a test then I like to take a step back to evaluate why.</li><li>Encouraging Costly Extract Refactors. I'm not exactly sure why Justin calls extraction refactors "costly". Sure, it takes a moment to decide what makes sense as its own responsibility, but this step still seems fairly straightforward.</li><li>Characterization Tests of Greenfield Code. I believe this is a valid critique if you assume that every unit needs to have a corresponding test around it. In response, Uncle Bob says that plenty of his "units" have no direct tests; they're tested indirectly by their client classes. This is a difficult problem to diagnose since it's heavily context-dependent. I usually make this judgement call by figuring out if the extracted class/function is doing a lot of heavy-lifting.</li><li>Redundant Test Coverage. This goes hand-in-hand with the last portion. Having duplicate test coverage gives you a high degree of confidence but is a real pain to change. The solution here is just to avoid this as carefully as you can.</li><li>Eliminating Redundancy Sacrifices Regression Value. Removing the duplicate coverage mentioned above results in less test coverage at the seams. Adding integration tests would probably be helpful here.</li><li>Making a Mess with Mocks. Assuming the same scenario Justin mentions, I agree on this point. The developer just has to be careful with how much they mock out so they don't paint themselves into a corner.</li></ul><div>Jason's post is pretty interesting and worth reading so I'd like to tackle the rest of his post in a separate post of my own.</div><br />
