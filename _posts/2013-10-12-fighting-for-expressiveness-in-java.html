---
layout: article
title: Fighting For Expressiveness in Java Unit Tests
date: '2013-10-12T11:39:00.000-07:00'
author: aml
tags: 
modified_time: '2013-10-12T11:49:28.376-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1561862341790331430
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/10/fighting-for-expressiveness-in-java.html
---

<b>The Problem</b><br /><br />Recently, I was writing a test for one of the classes in my <a href="https://github.com/arlandism/http-server" target="_blank">http-server project</a> and came across a hurdle. I wanted to pass in a mock and then make assertions using some of the methods implemented in the mock. The problem was that I wanted to clearly show the interface that the mock was implementing. The code looked something like this:<br /><br /><br /><pre class="brush:java" name="code">@Test<br />public void testExample(){<br />    RequestFactory factory = new MockRequestFactory();<br />    Server server = new Server(factory)<br />    server.respond();<br />    assertEqual(1, factory.requestsGenerated());<br />}<br /></pre><br />That's what the ideal solution would've looked like. Anyone browsing the code would immediately realize that the "Server" class takes a "RequestFactory" type. Unfortunately, this code doesn't work since the method "requestsGenerated" lives in the mock class and isn't declared in the interface. It's like the compiler is saying, "Hey, there's a RequestFactory declaration so we'll only work with methods that live in that interface."<br /><br /><b>The Solution</b><br /><br />I managed to find a workaround to the problem that's a bit ugly.<br /><br /><br /><pre class="brush:java" name="code">@Test<br />public void modifiedTestExample(){<br />    MockRequestFactory mockFactory = new MockRequestFactory();<br />    RequestFactory factory = mockFactory;<br />    Server server = new Server(factory)<br />    server.respond();<br />    assertEquals(1, mockFactory.requestsGenerated());<br />}<br /><br /></pre>This code says something along the lines of, "Make a mock, and then create a new variable that takes on the value of that mock. Pass the new variable in to the Server class, but make assertions using the original variable." I imagine all this really does is create two variables pointing to the same place in memory, except I can actually use the mock methods on the declared mock.<br /><br /><b>Why Bother?</b><br /><br />One obvious solution to the problem would be this: <br /><br /><pre class="brush:java" name="code">@Test<br />public void testExampleWithoutInterface(){<br />    MockRequestFactory factory = new MockRequestFactory();<br />    Server server = new Server(factory);<br />    server.respond();<br />    assertEquals(1, mockFactory.requestsGenerated());<br />}<br /></pre><br /><br />Why go through all this trouble? I did it for the expressiveness. Instantiating a mock of type "MockRequestFactory" obscures the fact that the "Server" class takes a type "RequestFactory". Sure, anyone familiar with unit-testing in Java will probably understand that the mock is implementing some interface, but they still won't know what that interface is. This leaves another class for them to look through when, ideally, the tests should show all of the relevant information.<br /><br /><b>Drawbacks</b><br /><b><br /></b>This test becomes much harder to read after implementing this technique. Were this my first time viewing the code I would certainly be scratching my head in confusion.<br /><br /><b>Summary</b><br /><b><br /></b>While it's certainly true that some indirection has been introduced here, it serves my purposes well enough for me to stick with it.<br /><br />P.S. I would actually take this a step farther and implement the mock somewhere in the "setUp" method. All this test should talk about is the idea that the "Server" takes a "RequestFactory" and generates a request. Though, since this code's idea is a bit obfuscated by the workaround maybe keeping the mock's instantiation here would help to clarify things.
