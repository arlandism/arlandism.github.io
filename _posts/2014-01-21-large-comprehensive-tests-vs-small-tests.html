---
layout: article
title: Large, Comprehensive Tests Vs Small Tests
date: '2014-01-21T19:01:00.000-08:00'
author: aml
tags:
- apprenticeship
modified_time: '2014-01-23T19:01:46.513-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-2553903205205760741
blogger_orig_url: https://immutablearlandis.blogspot.com/2014/01/large-comprehensive-tests-vs-small-tests.html
---

Today, I had an interesting discussion with Kelly over whether it was okay to stub out functions in the class under test. The discussion began when we started to write a test against a high-level function that was essentially just stringing together smaller functions. Kelly argued that we should either delete the tests we had written and stick with this more comprehensive test or stub the lower-level functions that it was gluing together. Her main concern was that we would be executing code that had already been executed in previous tests.<br /><br /><b>Example</b><br /><br /><pre class="brush:ruby" name="code">class StringCalculator</pre><pre class="brush:ruby" name="code"></pre><pre class="brush:ruby" name="code">  def self.compute(string_op)</pre><pre class="brush:ruby" name="code">  end</pre><pre class="brush:ruby" name="code"></pre><pre class="brush:ruby" name="code">  def self.determine_operation(string_op)</pre><pre class="brush:ruby" name="code">  end</pre><pre class="brush:ruby" name="code"></pre><pre class="brush:ruby" name="code">  def self.parse_numbers(string_op)</pre><pre class="brush:ruby" name="code">  end</pre><pre class="brush:ruby" name="code">end<br /><br />end<br /></pre><pre class="brush:ruby" name="code"></pre><pre class="brush:ruby" name="code"># Tests against determine_operation and parse_numbers</pre><pre class="brush:ruby" name="code"># Should we stub them in a test against compute?</pre><br /><b>Issues</b><br /><b><br /></b>To me, deciding to stub a class under test feels like an unconscious decision that the class is doing too much. If we assume a "unit" is the smallest cohesive component of a system then faking out pieces of that "unit" alters its cohesiveness in the test. This seems fine in the case where writing the next test is conceptually difficult, but it also seems to indicate that the "unit" isn't smallest enough to reason about. Another issue I have with this approach comes from my experience with wiring together different components in a system. Inevitably, there are tricky class/function interactions to watch out for and often these issues don't get noticed until the app is used. I feel like in-class stubbing could lead to a rise in these scary seams.<br /><br />Dave chimed in by saying the decision was more associated with style than good testing strategy. Though I disagreed, I found Kelly's point warrants some further thought. It would seem that in order to reduce noise you'd want to execute as much production code as possible in as little test code as possible. I've tried tackling this issue before, using really comprehensive tests to execute lots of code. I found that while the amount of noise in test files is certainly reduced, the tests are much more likely to miss nuances and edge cases. That being said, another potential strategy is to throw as many nuances into one test as possible. This is difficult and often obscures intent.<br /><br /><br /><pre class="brush:ruby" name="code">it "executes operations found in a string" do<br />  StringCalculator.compute("1 + a + 2").should== 3<br />end<br /></pre><br />Did you notice the 'a' I threw in there? This test demonstrates that "StringCalculator" does indeed ignore non-numeric characters, but it's not very explicit.<br /><br />This is more verbose, but preferable in my opinion:<br /><br /><br /><pre class="brush:ruby" name="code">it "executes operations found in a string" do<br />  StringCalculator.compute("1 + 2").should== 3<br />end<br /><br />it "ignores non-numeric characters" do<br />  StringCalculator.compute("1 + a + 2").should == 3<br />end<br /></pre><br /><b>Conclusion</b><br /><b><br /></b>Overall, I think progressively comprehensive unit tests are the best strategy.
