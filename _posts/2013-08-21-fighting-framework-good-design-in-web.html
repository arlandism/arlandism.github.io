---
layout: post
title: 'Fighting the Framework: Good Design in Web Apps'
date: '2013-08-21T07:33:00.002-07:00'
author: aml
tags: 
modified_time: '2013-08-21T07:37:25.709-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-772533770095810666
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/fighting-framework-good-design-in-web.html
---

<a href="http://immutablearlandis.blogspot.com/2013/08/i-want-cookies.html" target="_blank">My last post</a> talked about some possible abstractions for the Tic Tac Toe web application I've been working on. I managed to come up with a pretty good solution that led to some insight. I decided to introduce a layer of abstraction between the main controller file and the state of the game. This allowed me to "fight the framework".<br /><br />Brian Pratt, a software craftsman at 8th Light, gave a <a href="https://vimeo.com/72195902" target="_blank">great talk</a> about the architecture of one of our internal applications, Artisan. In that talk, he talks about some of the various strategies he employed to "fight" the Rails framework. There's lots of magic that goes on in a web framework - magic that makes applications easier to deploy, but harder to abstract.<br /><br /><b>Fighting Sinatra</b><br /><b><br /></b>Sinatra controllers are granted access to response and request headers. To fight against this, I pass those headers to another class that actually does the setting of the cookies. This removes the logic from the controller; it just snatches its relevant query parameters and passes them down. The class on the other side handles the actual setting of the cookies.<br /><br />Why is this important? Because without this extra layer of abstraction the Sinatra controller becomes a God class. And we don't want our controllers being omnipotent!<br /><br /><pre class="brush:ruby" name="code">class TTTDuet &lt; Sinatra::Base<br /><br />  get '/' do<br />    @board = request.cookies<br />    haml :index <br />  end<br /><br />  get '/clear' do<br />    StateManager.new(request,response).clear_cookies<br />    redirect '/'<br />  end<br /><br />  get '/config' do<br />    haml :config<br />  end<br /><br />  post '/config' do<br />    StateManager.new(request,response).set_difficulty(params[:difficulty])<br />    redirect '/'<br />  end<br /><br />  post '/move' do<br />    move = params[:player_move]<br />    StateManager.new(request, response, move).set_cookies<br />    redirect '/'<br />  end<br /><br />end<br /></pre><pre class="brush:ruby" name="code"><br /></pre><b>Layered Abstractions</b> <b></b>I've managed to delegate the duties of setting cookies and retrieving cookies from the service side down a layer, but I think there are maybe two abstractions hiding in this class. One of them knows what to expect from the service side, while the other is essentially a cookie manager. This is an amazing insight since I just pushed all this logic down. That means before the refactor the controller had three responsibilities: routing, setting cookies, and retrieving game-specific cookies.    <b>Testing the New Layers</b> <b></b>How do we handle the tests for a case like this? Well, everything is thoroughly tested since the new class was conceived out of the old controller logic. But, all of the tests live in the main app's spec file. This makes me think I should separate them out and only expose the controller's routing logic in the main spec file.    I don't think it's necessary to write any new test cases. I'm only accessing the new class API through the controller and the main controller tests assert the needed functionality.    <b>Summary</b> <b></b>Fight the framework! Frameworks are very powerful, but hide a lot of the action from you. Often, you'll find it necessary to introduce your own powerful abstractions to reduce coupling. 