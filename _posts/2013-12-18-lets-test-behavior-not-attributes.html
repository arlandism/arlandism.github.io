---
layout: article
title: Let's Test Behavior, Not Attributes
date: '2013-12-18T07:04:00.002-08:00'
author: aml
tags: 
modified_time: '2013-12-18T07:04:59.400-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-3393713922058405055
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/12/lets-test-behavior-not-attributes.html
---

I've stumbled across this testing idiom far too often:<br /><br /><br /><pre class="brush:ruby" name="code">describe Board do<br />  it "has players" do<br />    player_one = MockPlayer.new<br />    player_two = MockPlayer.new<br />    board = Board.new(player_one, player_two)<br />    board.player_one.should == player_one<br />    board.player_two.should == player_two<br />  end<br />end<br /></pre><br />There are good things about this test: <br /><br /><ul><li>It describes the Board constructor's signature; it expects two players.</li><li>It tells me that the players are accessible through the Board class.</li></ul><div>But, there are also bad things about this test:</div><div><ul><li>In most cases where I've seen this idiom, the attributes were only accessible because of the need for testing.</li><li>It doesn't test behavior; having attributes doesn't mean that you do anything with those attributes.</li></ul><div><b>Why They're Bad</b></div></div><div><b><br /></b></div><div>Ideally, tests are supposed to act like clients. The reason that we test-drive classes/functions is because we can describe their behavior from the perspective of an actual consumer of the class/function. Maybe there's a reason for a client to know what variable the Board class stores the players in, but like I said, that hasn't been the case in most instances that I've seen. I'd much rather imply this sort of persistence.</div><div><br /></div><div>What does the Board class do? For the sake of example, let's assume that the Board class moves the players and then they have a space on the board.<br /><br /></div><pre class="brush:ruby" name="code">describe Board do<br />  it "moves the players" do<br />    player_one_move = 3 <br />    player_two_move = 5<br />    player_one = MockPlayer.new(player_one_move)<br />    player_two = MockPlayer.new(player_two_move)<br />    board = Board.new(player_one, player_two)<br />    board.move_players!<br />    board.space(player_one_move).should be_occupied_by(player_one)<br />    board.space(player_two_move).should be_occupied_by(player_two)<br />  end<br />end<br /></pre><br />This test has more overhead, but that's because behavior is actually being tested now. If this is the reason that the board needs players then let's talk about it and not unnecessarily expose the internals of the Board class, lest we couple our tests to our implementation.<br /><br /><b>Conclusion</b><br /><b><br /></b>In reality, the first test isn't as harmful as I may have made it out to be; I just don't see a use for it. I like my tests to fail purposefully and other than when the first test was written, assuming it was written TDD-style, I'm not sure it would ever fail. Variable assignment isn't a complex behavior. The reason the first test shouldn't exist is the same reason we don't test data or markup: they're not worthy of our testing time.
