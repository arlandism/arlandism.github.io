---
layout: article
title: Implementing Cookies in Sinatra
date: '2013-07-29T14:59:00.001-07:00'
author: aml
tags: 
modified_time: '2013-07-29T15:00:07.829-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7640756897011105708
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/07/forms-and-cookies-in-sinatra.html
---

I had a rough weekend. I spent half of Saturday and all of Sunday trying to come up with a solution for handling Tic Tac Toe state in Sinatra. Eventually, I ditched my old efforts and decided to go the cookie route. Unfortunately, I couldn't find a whole lot of documentation on cookies in Sinatra; luckily, there were a few kind souls that had posted tutorials on the subject. Here's the solution I came up with:<br /><br /><br /><pre class="brush:ruby" name="code"> get '/' do<br />    @board = request.cookies<br />    haml :index <br />  end<br /><br />  post '/move' do<br />    move = params[:player_move]<br />    response.set_cookie(move, "x")<br />    redirect '/'<br />  end<br /></pre><br />Yeah, it's pretty underwhelming. You can set a cookie with the method "set_cookie" on the response object. After redirecting, the cookies are available for use in the 'request' object that Sinatra generates. In the index, I assign the cookies to a variable that will be passed in to the template page. The template page will render a button with a token on it if there's supposed to be a token in that spot.<br /><br /><b>Cookie Testing</b><br /><b><br /></b>The rack testing suite provides a convenient way to check the values on your cookies. Here's how my tests look:<br /><br /><br /><pre class="brush:ruby" name="code"><br />   it "stores a move cookie " do<br />      post_request_with_valid_move<br />      check_cookie_state(6,"x")<br />    end<br /><br />    it "has cookies that are persistent across requests" do<br />      post_request_with_valid_move<br />      get '/'<br />      check_cookie_state(6,"x")<br />    end<br /><br />    def post_request_with_valid_move(move=6)<br />      post '/move', {:player_move =&gt; move.to_s}<br />    end<br /><br />    def check_cookie_state(key,val)<br />      rack_mock_session.cookie_jar[key.to_s].should == val<br />    end<br /></pre><br />Rack::Test::Methods enables a rack_mock-session.cookie_jar that can be tested against. And, as my tests should indicate, it sticks around through multiple requests. That 'check_cookie_state' method just makes an assertion about what's stored in the cookie jar at a particular key.<br /><br />One thing about my tests is that I set the cookie based on some form input. Well, that can be mocked out pretty easily. To mock a form, you submit a normal request, along with a hash of name-value pairs that you want to mock. So, I send 'POST' requests with a hash specifying what I wish for a form to return.<br /><br />To add Rack::Test::Methods to your testing arsenal, use an "include Rack::Test::Methods" inside the first &nbsp;"describe whatever" block. Example:<br /><br /><br /><pre class="brush:ruby" name="code">require './main'<br />require 'rack/test'<br /><br />describe 'main' do<br />  include Rack::Test::Methods<br />  other_test_stuff<br />end<br /></pre>
