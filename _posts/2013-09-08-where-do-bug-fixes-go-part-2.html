---
layout: article
title: Where Do Bug Fixes Go? Part 2
date: '2013-09-08T10:10:00.002-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-09-08T10:11:05.774-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-6200842187182881420
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/where-do-bug-fixes-go-part-2.html
---

This is a follow-up post to my <a href="http://immutablearlandis.blogspot.com/2013/08/where-do-bug-fixes-go.html" target="_blank">"Where Do Bug Fixes Go"</a> post that I wrote a couple of weeks ago.<br /><br />As bugs start to appear in my code I'm forced to figure out where to solve the problem - where as in which class should I put the "squashing" code in.<br /><br /><b>Gradual Patches</b><br /><b><br /></b>Thus far, my solution has consisted of gradually hunting down the bug and adding fixes along the way - creating patches at every object that the bug could reach. This solution is inelegant, but gets the job done if trudging through every line of code to search for the bug isn't an option. What forces me to reconsider the problem is when I actually know where the bug is coming from. Then, where do I patch it?<br /><br />One obvious choice would be the class where it sneaks in. Sure, that's once place. But, should the classes surrounding that class be more robust? Should they be guarded against the junk that adjoining classes could pass in? I feel like there's a yes/no answer here. Yes, classes should be guarded against the dangers of their neighboring classes, to a reasonable extent! We're going down a circular path here when we start to consider what's actually "reasonable".<br /><br /><b>Type-Checking</b><br /><b><br /></b>I do know that writing the same checks around the boundaries of every class is very anti-DRY. This is an area where static languages have a huge advantage! There's type safety so you have a very good answer to the question of what's "reasonable" to check against - the type you're expecting from a method call. If your method signature tells me you're going to be returning a value of type 'Apprentice' then I can be assured that the value I get will respond to 'writeTicTacToe'. It then falls on that value to check against any "reasonable" input that it's expecting.<br /><br />In a sense, dynamic languages have this capability, but it has different ramifications. I'd much rather catch that 'incompatible types' error at compile-time.<br /><br /><b>Summary</b><br /><br />The point I'm getting at is it's hard to define a universal responsibility check that says "You should only watch out for these types". Because of this, it's hard to narrow down what kinds of bugs to check for and in which areas to check for them.
