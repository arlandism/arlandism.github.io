---
layout: article
title: Improved Testing Workflow
date: '2013-10-02T21:59:00.001-07:00'
author: aml
tags: 
modified_time: '2013-10-02T21:59:58.940-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7325439901969953487
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/10/testing-workflow.html
---

I've come a long way in my testing strategy and I'm finally starting to realize the productivity gains associated with it.<br /><br />While working on my Java server, I had three separate tests that checked the server's response after a request had been submitted through a socket.<br /><br /><br /><pre class="brush:java" name="code">    @Test<br />    public void testResponseStatus(){<br />        sendPingRequest();<br />        server.respond();<br />        String response = readResponse();<br />        assertTrue(response.startsWith("HTTP/1.0 200 OK"));<br />    }<br /><br />    @Test<br />    public void testResponseContentType() {<br />        sendPingRequest();<br />        server.respond();<br />        String response = readResponse();<br />        assertTrue(response.contains("Content-type: text/html"));<br />    }<br /><br />    @Test<br />    public void testResponseBody() {<br />        sendPingRequest();<br />        server.respond();<br />        String response = readResponse();<br />        assertTrue(response.contains("<html><body>pong</body></html>"));<br />    }<br /></pre><br /><b>Sidenote</b>: I acknowledge this could probably be simplified to one large assertion, but I like the clear separation of concepts here: Does the response status look the way we expect? And the content type? I think three separate assertions are more expressive.<br /><br />I implemented some new functionality - different responses for different requests - that forced me to introduce the notion of a response builder in my code. Following my standard workflow, I refactored to a method and then extracted a class. This class - ResponseBuilder - presented a new testing opportunity. Since this class arose out of previously tested code there's no reason to devise completely new unit tests for it. However, a huge benefit of class extraction is the ability to push the original tests down into a test file for the new class. So, I wrote a test file for ResponseBuilder that contained the three tests above, written with instances of ResponseBuilder.<br /><br />But, what happens to the old tests?<br /><br />Well, it would be silly to have the same tests in two places. My strategy was to mush the three separate tests together into one large test and call it an integration test. It looks like this:<br /><br /><br /><pre class="brush:java" name="code">    @Test<br />    public void testIntegration() {<br />        sendPingRequest();<br />        server.respond();<br />        String response = readResponse();<br />        assertTrue(response.startsWith("HTTP/1.0 200 OK"));<br />        assertTrue(response.contains("Content-type: text/html"));<br />        assertTrue(response.contains("<html><body>pong</body></html>"));<br />    }<br /></pre><br /><br />One thing worth noting is that this destroys the notion of "unit tests" around the Server class where they used to be. This is fine, as the Server class just delegates to ResponseBuilder which there are unit tests around; it also does some messy IO, which is tested but I'm not sure you'd call that unit testing since it's working in tandem with the operating system's underlying IO implementations. <br /><br />I'm pretty proud of how instinctual my testing strategy has become.
