---
layout: article
title: Breaking Fat Interfaces
date: '2013-10-23T07:10:00.004-07:00'
author: aml
tags: 
modified_time: '2013-10-23T07:10:58.306-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7130907378453637355
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/10/breaking-fat-interfaces.html
---

I have this pretty fat interface right now:<br /><br /><br /><pre class="brush:java" name="code">public interface Request {<br /><br />    String headers();<br /><br />    Integer bytesToRead();<br /><br />    Boolean hasBody();<br /><br />    void setBody(String body);<br /><br />    void sleep(Sleeper sleeper);<br /><br />    String fooValue();<br /><br />    String barValue();<br /><br />    String requestedResource();<br />}<br /></pre><br /><br />The problem with this interface is that its too general. I have this "Request" interface that has varied clients. Different clients use different parts of the interface for different reasons and there's no single client that uses all of the methods. This seems like a pretty direct violation of the Interface-Segregation Principle (i.e. don't have fat interfaces because a change to one part of the interface that should directly impact one client will indirectly impact other clients.)  <br /><br />In my code this could be something like changing the "sleep" method of one client, but having to recompile every client of the "Request" interface because of this change. I'm not completely sure of how Java handles its "linking", so I don't know if clients actually have to be recompiled, but either way there is something "smelly" about having this large body of methods with different clients using small sections of it for different things. It seems to be a sign that the interface should be broken up. <br /><br />In my case, I'm not exactly sure how to manage this. There's one client that catches "Requests" and then dispatches them accordingly. The classes it talks to are the ones that use different parts of the "Request" interface. The one client gets its "Requests" through a "RequestFactory". This creates a problem since I can't alternate the signature of the factory's request-generating method to produce different implementations of "Request" - I could, but then clients would only be able to use the methods defined on the "Request" interface. It also seems awkward to have a bunch of different kinds of factories to generate the different kinds of "Requests".<br /><br />I look forward to thinking harder about this problem and trying to come up with a solution. I looked through PPP for examples that included factories instantiating different subtypes of an interface, but I couldn't find one. I've also browsed through Refactoring to look for similar patterns that Fowler has encountered and successfully refactored, to no avail. 
