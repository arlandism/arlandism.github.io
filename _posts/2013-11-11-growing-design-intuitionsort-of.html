---
layout: article
title: Growing Design Intuition...Sort Of
date: '2013-11-11T20:28:00.003-08:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-11-11T20:28:27.957-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7303368405732467689
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/11/growing-design-intuitionsort-of.html
---

<div>I finished introducing the "Logger" code to my Java server today. Last week, I pretty much only worked on SCNA stuff, so I kind of just started today. It was awesome to go from start to finish so fast. But, I felt dirty writing the code. Introducing the "Logger" to my project felt clunky and ugly and I'm sure it's because I didn't evolve my design to fit with the new feature.</div><div><br /></div><div>In the system's current design, I knew that I needed to be able to pass in the "Logger" to the "Server" through its constructor. The class now looks like this:<br /><br /></div><div><pre class="brush:java" name="code">    public Server(NetworkIO networkIO, RequestFactory requestFactory, <br />                  ResponseBuilder builder, FeatureParser parser, <br />                  Logger logger) {<br />        this.networkIO = networkIO;<br />        this.requestFactory = requestFactory;<br />        this.builder = builder;<br />        this.parser = parser;<br />        this.logger = logger;<br />    }<br /><br />    public void respond() {<br />        request = nextRequest();<br />        response = builder.generateResponse(request, parser);<br />        logger.log(request.headers() + "\n" + response);<br />        networkIO.send(response);<br />    }<br /><br />    private Request nextRequest() {<br />        Request request = null;<br />        try {<br />            request = requestFactory.nextRequest();<br />        } catch (IOException e) {<br />            e.printStackTrace();<br />        }<br />        return request;<br />    }<br /><br /></pre><br /></div><div>The constructor takes five arguments, which seems like a huge smell to me. The conclusion that I draw from this is that the "Server" has too much responsibility. What's funny is that I usually use LOC as a heuristic for determining a class' responsibility level, yet the "Server" is amongst the smallest classes in the system. Obviously, it's not doing much heavy lifting, but maybe it has too much knowledge about the system.<br /><br />It's great to be able to notice flaws like this when they occur. Something felt wrong while writing this code. The problem is that I have no idea how what a better design looks like or how to get there. Having unit tests around classes makes it really easy to change those classes without worrying about their internals. Redesigns usually involve manipulating the internals and externals of a system, which is a skill that I'm still working on. I think the key difference here is having a specified end goal in mind. One of the reasons TDD is so effective is because you can codify the end goals for a class through the lens of a client of that class. With a redesign, there's no quantitative bar to measure against.<br /><br />It's great to spot design smells when they occur, but figuring out how to fix them is hard.</div>
