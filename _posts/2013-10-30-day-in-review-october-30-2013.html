---
layout: post
title: Day In Review - October 30, 2013
date: '2013-10-30T19:58:00.003-07:00'
author: aml
tags: 
modified_time: '2013-10-30T20:19:27.112-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-6347005112249714591
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/10/day-in-review-october-30-2013.html
---

The feature I'm working on this week for my server is the ability to toggle features. I have two options: parsing an XML file or command line arguments; bonus points for both.<br /><br />Today, I worked on refactoring the conditional routing logic into a single data structure that I'll be able to pass in as an argument to my response builder. This way, the routes can be defined before the user starts querying for responses, which gets me one step closer to toggling.  <br /><pre class="brush:java" name="code"><br />      Response response;<br /><br />        if (isFormRequest(request)) {<br /><br />            response = new GetFormResponse();<br /><br />        } else if (isPostRequest(request)) {<br /><br />            response = new PostFormResponse(request);<br /><br />        } else if (isSleepRequest(request)) {<br /><br />            response = new SleepResponse(request, new ThreadSleeper());<br /><br />        } else if (isResourceRequest(request)) {<br /><br />             response = fileResponseFactory.fileResponse(request, retriever);<br /><br />        } else if (isServiceRequest(request)){<br /><br />            response = new ServiceResponse(service, request);<br /><br />        } else if (isPongRequest(request)){<br /><br />            response = new PongResponse();<br /><br />        } else {<br /><br />            response = new FeatureNotFoundResponse();<br /><br />        }<br /><br />        return "HTTP/1.0 200 OK" + "\r\n" + "Content-type: " + response.contentType() + "\r\n\r\n" + response.body();<br /></pre><br />I managed to kill a few dozens lines of code by switching to a HashMap implementation. <br /><pre class="brush:java" name="code"><br />    public String generateResponse(Request request) {<br />      Response response;<br />      requestHeaderToResponse.put("GET /ping", new PongResponse());<br />      requestHeaderToResponse.put("GET /form", new GetFormResponse());<br />      requestHeaderToResponse.put("POST /form", new PostFormResponse(request));<br />      requestHeaderToResponse.put("GET /ping?sleep", new SleepResponse(request, new ThreadSleeper()));<br />      requestHeaderToResponse.put("GET /game", new ServiceResponse(service, request));<br />      response = findResponse(requestHeaderToResponse, request);<br /><br />      return "HTTP/1.0 200 OK" + "\r\n" + "Content-type: " + response.contentType() + "\r\n\r\n" + response.body();<br />    }<br /><br />    private Response findResponse(Map &#60String, Response&#62 registeredHeaders, Request request){<br /><br />      for (String route: registeredHeaders.keySet()){<br />          if (request.headers().startsWith(route))<br />              return registeredHeaders.get(route);<br />      }<br /><br />      if (isResourceRequest(request)){<br />          return fileResponseFactory.fileResponse(request, retriever);<br />      }<br /><br />      return new FeatureNotFoundResponse();<br />    }<br /></pre><br />The primary problem I'm facing now is that a lot of the responses take the 'Request' in their constructor. This will make it hard to build a routing object in Main since I won't have my hands on a 'Request' yet. I considered making the 'Response' classes static, passing them in according to the configured routes in Main, and then calling the appropriate builder method farther down. Basically, pass in a bunch of factories to the routing object and worry about getting the instances farther down when I can get my hands on a 'Request'. This is one idea, but it seems like a lot of work, which makes me think there's a simpler solution.