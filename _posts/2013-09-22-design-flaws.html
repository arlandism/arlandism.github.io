---
layout: article
title: Design Flaws
date: '2013-09-22T18:31:00.001-07:00'
author: aml
tags: 
modified_time: '2013-09-22T18:31:22.701-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1265141643346109271
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/design-flaws.html
---

I found a bug in my newly implemented feature today and I've been doing the standard post-bug introspection: asking myself questions like, "How could this have been avoided?" and "Is there a test I could've written that would've caught this?".<br /><br />I've come to the conclusion that there's no obvious test I could've written that would've led me to stomp out the bug. I think the main problem stems from a questionable design decision I made to implement a separate feature.<br /><br /><b>I.D. Assignment</b><br /><br />The application assigns ids to games by incrementing the last i.d. found in the game storage system. the bug occurs when you visit the configuration page of the application and choose an AI player as the first to move. No matter the previous i.d., the game will always be assigned an i.d. of 0.<br /><br />The problem lies in the fact that, conceptually, i.d. assignment is coupled to game flow. The controller that dishes out the i.d. looks like this:<br /><br /><br /><pre class="brush:ruby" name="code">  post '/move' do<br />      id = cookies["id"] || History.next_id(settings.history_path)<br />      response.set_cookie("id",id)<br />      token_one = token(cookies)<br />      place_move_on_board(first_player_move,token_one)<br /><br />      token_two = token(cookies)<br />      place_move_on_board(next_player_move,token_two)<br /><br />      place_winner_on_board<br />      redirect '/'<br />  end<br /></pre><br />It checks first to see if an i.d. already exists and if it doesn't creates a new one. This is fine except for the special case in which an AI player goes first. The logic for that feature actually happens in a second controller. <br /><br /><pre class="brush:ruby" name="code">  get '/' do<br />      if CpuMove.should_place(cookies.to_hash) <br />        place_move_on_board(next_player_move, token(cookies))<br />      end<br />      haml :index <br />  end<br /></pre><br />Here, the i.d. generation doesn't take place. Inside of the "place_move_on_board" function is where I actually make use of the i.d., but it's not being generated. For the final proverbial straw breaking the camel's back I give you the "place_move_on_board" function: <br /><br /><pre class="brush:ruby" name="code">  def place_move_on_board(move,token)<br />    response.set_cookie(move,token)<br />    id = cookies["id"].to_i<br />    History.write_move(id, move.to_i, token, settings.history_path)<br />  end<br /></pre><br /><br />Notice the "id = cookies['id'].to_i" line. Since we're not setting the i.d. before the AI moves this always results in zero. <br /><br />I think the biggest problem here is that making moves isn't centralized. Since it happens in two different places, it's hard to remember to set the logic for both. Unfortunately, the reason for this design decision remains: there's no other user-friendly way to implement the AI first feature. The alternative to implementing it this way is to have the user click a button for the AI to move, since the other move logic happens through the "post '/move'" route handler. This strikes me as gross from a user perspective.<br /><br /><b>The Bed is Made</b><br /><b><br /></b>Since that decision has already been made, I maybe need to think harder about another way to centralize move making. The bottom line is that since I knew the tradeoffs when I made the decision to implement the feature this way I should've been more alert to how nuances like this could impact the code.
