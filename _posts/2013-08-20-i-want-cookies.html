---
layout: article
title: I Want Cookies!
date: '2013-08-20T19:04:00.000-07:00'
author: aml
tags: 
modified_time: '2013-08-20T19:04:02.557-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-4231254622129648877
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/i-want-cookies.html
---

As my Sinatra web application scales, I'm finding that I have to make some very tough design choices. Chief amongst these concerns is how I should manage state - I chose to use cookies.<br /><br /><b>Considerations</b><br /><b><br /></b>My web application needs to know what to render to the user. Obviously, I need some sort of mechanism for handling state since the game isn't static. Under normal circumstances, I would be somewhat limited in my options since I'm relying on an independent service. But, since I just so happen to own the service I'm relying on, I have quite a few options.<br /><br /><b>Option 1</b><br /><b><br /></b>I could allow the user to make a move, send the move to the service side, and query the service for the state of the game whenever I need to render it. I really like this approach and it's pretty much a tie between this one and the choice I actually went with. The major drawback to this approach is that this would mean altering the service's API. While that's fine in this case, I most likely wouldn't have the luxury of this option if not for special circumstance.<br /><br /><b>Option 2</b><br /><b><br /></b>I could insert a layer under the Sinatra controllers that handles state. This could send moves and store results. I would just need to query this abstraction for the state of the game and present that logic to my views. I would argue that this could be unnecessary complexity, but I'm not completely sure. Take a look at this snippet from the controller.<br /><br /><br /><pre class="brush:ruby" name="code"> post '/move' do<br />    move = params[:player_move]<br />    response.set_cookie(move, "x")<br />    human_move = {move =&gt; "x"}<br />    board_state = Helpers.add_hashes(request.cookies, human_move)<br />    game_info = Helpers.call_ai(AI.new, {"board"=&gt; board_state}) <br />    comp_move = Helpers.ai_move(game_info)<br />    response.set_cookie(comp_move,"o")<br />    set_winner_if_exists(response,game_info)<br />    redirect '/'<br />  end<br /></pre><br />We can aptly summarize this code with this memorable quote: "This is too much power for one person." - Lucius Fox<br /><br /><b>Option 3</b><br /><b><br /></b>I could use cookies. This is the approach that I actually went with, and I'm somewhat regretting it now. Relying on cookies implicitly places a lot of pressure on the controller. The controller is endowed with "certain unalienable rights". I can't abstract away the setting of cookies in another place because that burden lies with the controllers. On the plus side, using cookies was relatively easy with the first use case. But, the complexity in maintaining them is becoming a bit of a headache that I'm not sure I want to deal with.<br /><br /><b>Summary</b><br /><b><br /></b>I discussed with my mentor a kind of refactoring between options 2 and 3. There would be some abstraction layer underneath the controllers that would communicate with the service side and pass the relevant information back. But, I would still be using cookies. Maybe after refactoring I'll be able to take a closer look at the controller code and decide if it's still too complicated.
