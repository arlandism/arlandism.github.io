---
layout: article
title: Decisions, decisions....
date: '2013-07-15T08:30:00.002-07:00'
author: aml
tags: 
modified_time: '2013-07-15T20:18:37.860-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5558937863562570581
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/07/decisions-decisions.html
---

Recently, I had to make some major changes to my Tic Tac Toe application. I'll discuss why I chose the design choices I did, and some of the pros and cons of each decision.<br /><br />Previously, I thought of the use cases of my application as specific scenarios. For example, if you wanted to run a game with two AI players then that was its own scenario and I'd call this class:<br /><br /><br /><pre class="brush:python" name="code">from easy_vs_impossible_ai import EasyVsImpossibleAiScenario<br /><br />class AiVsAiScenario(object):<br /><br />    def __init__(self,user_data):<br />        self.difficulty = user_data.get("What difficulty would you like the first ai to be (easy,impossible): ")<br /><br />    def setup(self):<br />        if self.difficulty == "easy":<br />            return EasyVsImpossibleAiScenario().setup()<br />        return Game(ImpossibleAI("x"),ImpossibleAI("o"))<br /><br />    @staticmethod<br />    def prompts():<br />        difficulty_prompt = {"What difficulty would you like the first ai to be (easy,impossible): ": ("easy","impossible")}<br />        # Passes prompts to OrderedDict creator<br />        return NoPromptInterface.prompts(difficulty_prompt)<br /></pre><br />For awhile (up until Friday), I thought this was a good idea. It allowed me to break down different game setups into their own classes and handle more specific logic there. There was this ScenarioSelector class that figured out which scenario to pass back. The whole reason that this scenario pattern emerged was because there were some things that needed to be asked for one scenario (If you wanted a Human Vs AI game for instance) versus another (If you wanted AI vs AI). This made it seem like each game scenario should exist within its own space. A new problem drove me to a new pattern.<br /><br />If I wanted to extend my use cases then I had to add new scenario classes. So, if you wanted to watch two Humanoids (A Humanoid is a hybrid of an AI and a Human player) face each other then I had to create a Humanoid Vs Humanoid class. This wasn't terrible since it felt very OCP compliant to me. If I needed a new use case, then I added another object; no modification of prior code. What I didn't realize was that there was a much simpler pattern waiting to emerge.<br /><br />What if we generalized the use case? What if, instead of saying that different kinds of games were the use cases, we said that creating "a" game was the use case. What I mean is that instead of having these pre-made game scenarios for every kind of game that could be created, I could ask questions and create the game scenario on-the-fly. This had some profound implications on my code base. But, to add this on-the-fly game creation, I had to rely on some common patterns.<br /><br /><b>The Factory</b><br /><b><br /></b>The first thing I needed was a way to instantiate player objects. So, I get some information from the user and figure out which kind of players they want. But, we can't have the game creator knowing how to create players and games (We could, but I would sorry about an SRP violation here). Thus, the PlayerFactory emerges.<br /><br /><pre class="brush:python" name="code">class PlayerFactory(object):<br /><br />    @staticmethod<br />    def player(player_type,token):<br />        if player_type == "EasyAI":<br />            return ImpossibleAI(token,minimax=Minimax(token,1))<br />        players = {"Human":HumanPlayer,<br />                   "Humanoid":Humanoid,<br />                   "ImpossibleAI":ImpossibleAI}<br />        return players.get(player_type)(token)<br /></pre><br />This class knows how to translate strings to different player objects and spit out instances of players.<br /><br />Drawbacks:<br />So, there's one huge problem with this class. Primarily, it's an Open Closed Principle violation. If I need a new player type, then I have to add to this PlayerFactory. I think that's a cost worth incurring since I don't expect to be creating many new player types. Maybe there's a way to clean this up but I'm not sure how. On the plus side, it was a breeze to test it. There are only four player types!<br /><br /><b>The Builder</b><br /><b><br /></b>I'm not exactly sure if this is the "pure" builder pattern referred to in OOP books. I just thought it was a fitting name for what this class does; it builds games!<br /><br /><pre class="brush:python" name="code">from game import Game<br />from player_factory import PlayerFactory<br />from base_board import BaseBoard<br />from prompt_parser import PromptParser<br /><br />class GameBuilder(object):<br /><br />    @staticmethod<br />    def game(user_data):<br />        parser = PromptParser(user_data)<br />        player_one = PlayerFactory.player(parser.first_player(),parser.first_token())<br />        player_two = PlayerFactory.player(parser.second_player(),parser.second_token())<br />        board = BaseBoard(parser.board_size())<br />        return Game(player_one,player_two,board)<br /></pre><br />I love this class! It's so simple. Feed it some user data and it feeds you a game. It acts as a kind of bridging object between the Parser, UI, PlayerFactory, BaseBoard, and Game classes. How does this class work?<br /><br />Our PromptParser class knows how to translate user_input to relevant data. It then enables an interface to access that data. We saw how the PlayerFactory worked already. BaseBoard is just a board class that allows an index specifier; so if you want a 4x4 board then you pass in a 4 in the constructor. Game takes two players and a board object. Simple enough.<br /><br />Drawbacks:<br />Look at all those references! How do you test a behemoth like this? This class does something o-so-simple, but with so many references. Testing a class like this is hard, which makes me think that maybe a class with so much delegation is an SRP violation. On one hand, you could say "It builds games!", but on the other you could say "It parses user data, passes players to PlayerFactory, passes board size to BaseBoard, and builds games!". The fact that this class is pretty hard to test maybe points towards the latter description. I also think it would be really smelly to inject so many dependencies. Maybe this class' responsibilities should be broken down into other classes. But, then I worry about unnecessary complexity.<br /><br />The PromptParser is unlikely to change very much, but what about the BaseBoard and Game classes? If they change then that really screws things up.<br /><br /><b>Conclusion</b><br /><b><br /></b>These two classes allowed me to eliminate a ton of code from my application. The ScenarioSelector class, which was pretty much a ScenarioFactory now that I think about it, was completely unnecessary. By creating the PlayerFactory I can create player objects as needed and don't need to hold references to every possible configuration of two player games. I've sacrificed for this simplification though. If I need to add a player then I've got to manually add it to the PlayerFactory. If BaseBoard or Game changes then I have to modify the GameBuilder. And the GameBuilder's really hard to test with all those dependencies. With all that being said, I'm hoping for a solution that lets me keep this pattern, with maybe a cleaner way to run tests and be protected from change.
