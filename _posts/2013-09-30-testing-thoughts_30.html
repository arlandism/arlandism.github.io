---
layout: article
title: Testing Thoughts
date: '2013-09-30T09:11:00.001-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-09-30T09:11:52.472-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5284875111590117192
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/testing-thoughts_30.html
---

One of the themes that my upcoming kata explores is testing new code with old code. Essentially, something like this:<br /><br /><pre class="brush:ruby" name="code">describe add_two do<br />  it "adds two numbers" do<br />    add_two(2, 2).should == 4<br />  end<br />end<br /><br />def add_two(num, num_two)<br />  num + num_two<br />end<br /><br />describe add_three do<br />  it "adds three numbers" do<br />    add_three(2,3,4).should == add_two(2, add_two(3, 4))<br />  end<br />end<br /></pre><br />This is a contrived example, but I think it expresses the point well enough. This technique seems reasonable since we're testing based on functions that we've previously tested and proved that they do what we want.<br /><br /><b>Usefulness</b><br /><b><br /></b>Why is this useful? There are times that writing a test can be really hard because of the depth of its implementation. One example of this is in my kata where I sum every force acting on a given body. I have a function before this "sum-all-forces" function that computes the force acting on one body from another. Thus, the simplest way to test the "sum-all-forces" function is to create an assertion that adds multiple "force-on-a-body" functions. Other than testing this way, there's no fast way to compute the values that this function should yield - save for having the values pre-computed. I often use this approach when I need to do complicated data transformations.<br /><br /><b>Downsides</b><br /><b><br /></b>The biggest con to this approach is that you may end up test-driving a bunch of smaller functions that you'll never use. In my adding example above, the "add_two" function probably won't be used by any client since it exists for the sole purpose of decomposing the larger function that we actually want to get at. This can lead to a solution that we're confident in but forces us to test a bunch of private methods to arrive at that solution.<br /><br /><b>Summary</b><br /><br />Maybe the best approach here is to test-drive the smaller functions in order to complete that bigger-picture function. If possible, create one good test for the large function and discard the smaller tests. If done correctly, this test should pass as soon as you write it. If it's too hard to create one test for the behavior of the desired method, then perhaps consider breaking the smaller pieces into different classes. One final solution is to just keep the smaller tests, but this isn't ideal since the tests will know the internals of the class and make it really hard to change.
