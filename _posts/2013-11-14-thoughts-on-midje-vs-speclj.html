---
layout: post
title: Thoughts On Midje Vs Speclj
date: '2013-11-14T19:23:00.001-08:00'
author: aml
tags: 
modified_time: '2013-11-14T19:23:36.475-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5718100807269341335
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/11/thoughts-on-midje-vs-speclj.html
---

Over the weekend, I discovered Brian Marick and his Midje testing framework. Previously, I had been relying entirely on Speclj. Though Speclj is good, I saw some things about Midje that interested me.<br /><div><br /></div><div><b>Facts</b></div><div>Midje has a notion of "facts". Essentially, this is just Midje's implementation of assertions. What's cool about them is the way they read.</div><div><br /></div><div>(facts "about computation"</div><div>&nbsp; (fact "it always computes non-empty collections"<br />&nbsp; &nbsp; (let [collection-empty? (&lt; 0 (count (computation)))]</div><div>&nbsp; &nbsp; &nbsp; computation-empty? =&gt; false))</div><div><br /></div><div>Whereas, in Speclj, it would look like this:</div><div><br /></div><div>(describe "computation"</div><div>&nbsp; (it "always computes non-empty collections"<br />&nbsp; &nbsp; (let [collection-empty? (&lt; 0 (count (computation)))]</div><div>&nbsp; &nbsp; &nbsp; (should-not collection-empty?))))</div><div><br /></div><div>To me, the first implementation reads better.</div><div><br /></div><div><b>Stubbing</b></div><div><b><br /></b></div><div>In Speclj, I would stub like this:</div><div><br /></div><div>(describe "function-with-dependency-on-foo"</div><div>&nbsp; (it "returns :bar when foo is true"</div><div>&nbsp; &nbsp; (with-redefs [foo (fn [&amp; _] true)]</div><div>&nbsp; &nbsp; &nbsp; (should= :bar (function-with-dependency-on-foo)))))</div><div><br /></div><div>In Midje, we have this implementation:</div><div><br /></div><div>(facts "about function-with-dependency-on-foo"</div><div>&nbsp; (fact "it returns :bar when foo is true"</div><div>&nbsp; &nbsp; (function-with-dependency-on-foo) =&gt; :bar</div><div>&nbsp; &nbsp; &nbsp; (provided</div><div>&nbsp; &nbsp; &nbsp; (foo) =&gt; true)))</div><div><br /></div><div>Once again, I definitely think the Midje implementation reads better.&nbsp;</div><div><br /></div><div>The only issue I'm having with Midje is stubbing a function that doesn't exist yet. According to the documentation, it's something like:</div><div><br /></div><div>(unfinished foo)</div><div><br /></div><div>That works fine for the spec, but in the implementation's namespace, I get a "foo not defined" error. Hopefully, I'll be able to dig around some more and figure out why Midje isn't behaving the way I want it to. I'm hoping that switching over to Midje will help with transitioning my kata to a top-down approach versus the bottom-up approach I was shooting for before.<br /><br />Note: Figured out the problem. (unfinished foo) has to be declared in the source file, which kind of stinks.</div><div><br /></div><div><br /></div><div><br /></div>