---
layout: post
title: Composition Over Inheritance
date: '2013-07-01T17:22:00.001-07:00'
author: aml
tags: 
modified_time: '2013-07-02T07:01:38.874-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5851569096755085252
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/07/composition-over-inheritance.html
---

Everyone knows that polymorphism reduces code-reuse. That's the idea behind it. I thought that I had a pretty good grasp of its implementation while still adhering to Uncle Bob's SOLID principles. Turns out I was wrong. This was my AI class: <br /><pre class="brush:python" name="code">from player import Player<br />import random<br /><br />class AI(Player):<br /><br />  def __init__(self,token):<br />      super(AI, self).__init__(token)<br /><br />  def next_move(self,board):<br />      move_list = self.__build_move_list__(board)<br />      if move_list:<br />          best_move = max(move_list)[-1]<br />          return best_move<br /><br />  def __build_move_list__(self,board):<br />      move_list = []<br />      possible_moves = board.available_moves()<br />      for move in possible_moves:<br />          move_score = self.__best_score__(move,board,self.token)<br />          move_list.append((move_score,move))<br />      return move_list<br /><br />  def __best_score__(self, space, board, player, alpha=-1, beta=1):<br />      try:<br />          board.make_move(space,player)<br />          possible_moves = board.available_moves()<br />          if board.game_over():<br />              return self.__cost_function__(board.winner())<br />          next_player = self.PLAYERS_DICT[player]<br />          if self.__comp_turn__(player):<br />              for move in possible_moves:<br />                  beta = min(beta,self.__best_score__(move,board,next_player,alpha,beta))<br />                  if beta &lt;= alpha:<br />                      break<br />              return beta<br />          else:<br />              for move in possible_moves:<br />                  alpha = max(alpha,self.__best_score__(move,board,next_player,alpha,beta))<br />                  if beta &lt;= alpha:<br />                      break<br />              return alpha<br />      finally:<br />          board.erase_move(space)<br /><br />  def __cost_function__(self, winner):<br />      cost_dict = {self.opponent_token:-1, self.token:1, None:0}<br />      return cost_dict[winner]<br /><br />  def __comp_turn__(self, current_player):<br />      return current_player == self.token<br /><br /><br />class EasyAI(AI):<br /><br />  def next_move(self,board):<br />      move_list = self.__build_move_list__(board)<br />      easy_move_list = filter(lambda x: x[0] &lt; 1, move_list)<br />      move = random.choice(easy_move_list)<br />      return move</pre>Forget for a moment that AI inherits from the Player class. That's not the violation I'm referring to. I thought I was clever with EasyAI inheriting from AI and just re-constructing the next_move method. But, turns out this can be considered a Liskov violation. For the uninitiated, the Liskov Substitution Principle states that any subclass should be substitutable for its parent class. While both of my AI classes have the same interface (next_move), EasyAI can't be reasonably substituted for its base AI class. If we have some functionality that depends on the "intelligence" of the AI, then EasyAI fails as an appropriate substitute. A much cleaner solution is to abstract the two classes' commonalities into a seperate interface that they both have access to. This way there's no direct inheritance, but we can still support code-reuse. My revised version is below: <br /><pre class="brush:python" name="code">from printer import Printer<br /><br />class ImpossibleAI(object):<br /><br />    def __init__(self,token,display_object=Printer()):<br />        self.token = token<br />        self.display_method = display_object.display<br /><br />    def next_move(self,board):<br />        self.display_method(self.token.capitalize() + "'s turn")<br />        move = Minimax(self.token,6).next_move(board)<br />        self.display_method(self.token + " moves to " + str(move))<br />        return move<br /><br />class EasyAI(object):<br /><br />    def __init__(self,token,display_object=Printer()):<br />        self.token = token<br />        self.display_method = display_object.display<br /><br />    def next_move(self,board):<br />        move = Minimax(self.token,1).next_move(board)<br />        self.display_method(self.token.capitalize() + "'s turn")<br />        self.display_method(self.token.capitalize() + " moves to " + str(move))<br />        return move<br /><br />class Minimax(object):<br /><br />  PLAYERS_DICT = {'x':'o','o':'x'}<br /><br />    def __init__(self,token,max_depth):<br />        self.token = token<br />        self.opponent_token = self.PLAYERS_DICT[self.token]<br />        self.minimax_status = {"alpha":-1,"beta":1}<br />        self.MAX_DEPTH = max_depth<br /><br />    def next_move(self,board):<br />        score_and_move_list = self.__build_score_and_move_list__(board)<br />        if score_and_move_list:<br />            best_score_and_move_list = max(score_and_move_list)<br />            MOVE_INDEX = -1<br />            best_move = best_score_and_move_list[MOVE_INDEX] <br />            return best_move<br /><br />#Removed code underneath here for brevity<br /></pre>