---
layout: article
title: Functional Problem Solving With Ruby
date: '2013-09-26T19:10:00.004-07:00'
author: aml
tags: 
modified_time: '2013-09-26T19:13:03.006-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1483880085118502702
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/functional-problem-solving-with-ruby.html
---

I wrote some code today that I was pretty happy with. It dealt with data transformation, which made it a prime target for using some functional techniques.<br /><br />In summary, I get some information from my database and want to change its format before using it in the controller. I created a class, DBInterpreter, to handle this responsibility.<br /><br />The first use case of the DBInterpreter was for a single game. After reading the DataMapper docs I found that I could call 'model.attributes' to get a hash representation of the model's properties. This was exactly what I needed, except that the keys in the returned hash are symbols instead of strings. I figured there would be a simple workaround for this, but couldn't find a solution. Eventually, I stumbled onto a StackOverflow answer that used Ruby's inject method to achieve the desired behavior; I went with it. After some refactoring, the code for the first method of the DBInterpreter API looked like this:<br /><br /><pre class="brush:ruby" name="code">  <br />  def self.translate_game(game)<br />    {<br />      "moves" =&gt; game.moves.map { |move| attr_keys_to_str(move) },<br />      "winner" =&gt; game.winner<br />    }<br />  end<br /><br />  private<br /><br />  def self.hash_keys_to_str(hash)<br />    hash.inject({}) do |h, (key, val)|<br />      h[key.to_s] = val<br />      h<br />    end<br />  end<br /><br />  def self.attr_keys_to_str(model)<br />    hash_keys_to_str(model.attributes)<br />  end<br /></pre><br />I used the inject method for translating the symbols to keys and map that behavior to each move found in a game - both moves and games are represented as models. The transformation looks like this:<br /><br /><pre class="brush:ruby" name="code">&gt; move_from_db = Move.create(:game_id =&gt; 5, :position =&gt; 3, :token =&gt; "x")<br />&gt; move_from_db.attributes <br />{:position =&gt; 3, :token =&gt; "x"}<br />> game_from_db = Game.create(:game_id =&gt; 5)<br /><br />&gt; DBInterpreter.translate_game(game_from_db)<br /><br />{<br />  "moves" =&gt; [{"position" =&gt; 3, "token" =&gt; "x"}],<br />  "winner" =&gt; nil<br />}<br /></pre><br />Next up was to replicate this behavior for multiple games. This was pretty trivial after I had finished the code to translate an individual game. The end result for that methods looks like this:<br /><br /><br /><pre class="brush:ruby" name="code">  def self.translate_games(games)<br />    games.inject({"games" =&gt; {}}) do |acc, game|<br />      acc["games"][game.id] = translate_game(game)<br />      acc<br />    end<br />  end<br /></pre><br />Two reductions and a map did everything I needed. If not for working with a bit of Clojure recently, I wouldn't have been exposed to this style of problem-solving and probably would've constructed some way messier code.
