---
layout: article
title: My Thoughts On Test-Driving Design
date: '2013-08-13T19:07:00.003-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-08-13T19:07:54.912-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-7113424562487242940
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/my-thoughts-on-test-driving-design.html
---

The more I practice it, the more test-driven development seems like a fundamental tool to good software design. Tests not only serve as powerful checks for the functionality of production code, but they also serve as API documentation and effective design specifications.<br /><br />Starting out, test-driven development feels unnatural - akin to the first time you try a new sport. Your posture is off, things feel weird, and you focus more on getting the stance right than you do on actually hitting the target. But, as you practice more and more, you start to focus more on the bigger picture. Now, instead of trying to hit/hold/throw the ball, you can focus on where the ball should go. Eventually, you reach what Robert Greene refers to as "<i>a cycle of accelerated returns</i>". The big picture starts to get bigger and conversely your focus begins to narrow.<br /><br />Like all practices, this "cycle" eventually occurs with TDD. Getting used to the "red, green, refactor" rules take some time, but soon enough they become second nature. You start to reason about your code with the test suite in mind. Tests become less of a chore and more of a design driver. The "red, green, refactor" cycle that you only recently dreaded and rushed through in anguish, becomes a sanctuary where you can rationalize your design decisions and compose your thoughts.<br /><br />Below is some code that I test-drove today. The tests are extremely simple and so is the design.<br /><br /><pre class="brush:python" name="code">class ConfigParser(object):<br /><br />    def __init__(self,file_to_parse):<br />        self.to_parse = file_to_parse<br />         <br />    def token(self):<br />        return self.__find_it("token")<br /><br />    def player_one(self):<br />        return self.__find_it("player_one")<br /><br />    def player_two(self):<br />        return self.__find_it("player_two")<br /><br />    def difficulty(self):<br />        return self.__find_it("difficulty")<br />        <br />    def __find_it(self,to_find):<br />        PREFIX_LEN = len(to_find) + len(": ")<br />        start = self.to_parse.find(to_find + ": ") + PREFIX_LEN<br />        END_OF_VAL = self.to_parse[start: ].find("\n")<br />        found = self.to_parse[start:start + END_OF_VAL] <br />        return found<br /><br />## Begin Tests<br /><br />class ConfigParserTests(unittest.TestCase):<br /><br />    fake_config_file = ("token: test_token\n" +<br />                        "player_one: test_player_one\n" +<br />                        "player_two: test_player_two\n" +<br />                        "difficulty: juggernaut\n")<br /><br />    def setUp(self):<br />        self.parser = ConfigParser(self.fake_config_file)<br /><br />    def test_reads_from_input_for_token(self):<br />        token = self.parser.token()<br />        self.assertEqual("test_token",token)<br />        <br />    def test_reads_from_input_for_player_one(self):<br />        player = self.parser.player_one()<br />        self.assertEqual("test_player_one",player)<br />        <br />    def test_reads_from_input_for_player_two(self):<br />        player = self.parser.player_two()<br />        self.assertEqual("test_player_two",player)<br /><br />    def test_reads_from_input_for_difficulty(self):<br />        difficulty = self.parser.difficulty()<br />        self.assertEqual("juggernaut",difficulty)<br /><br /></pre><b>How It Works</b><br /><b><br /></b>The class reads from a config file and parses data according to a certain format. That's it.<br /><br /><b>Benefits</b><br /><br />Simplicity:<br />The class is simple enough that it should be fairly easy to understand it without explanation. The test suite drove me to this design. The class also seems fairly expressive, at least to me.<br /><br /><b>Drawbacks</b><br /><b><br /></b>The file to be read has to be composed in a certain format. This is to be expected with any kind of parser though. There's some standard formatting of data or else it doesn't know what to look for.<br /><br /><b>Summary</b><br /><b><br /></b>TDD is great and it gives me a lot more confidence in the functionality of my code. Also, it leads to simpler designs and APIs. Do it!<br /><b><br /></b>
