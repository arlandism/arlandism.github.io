---
layout: article
title: Template Pattern Vs. Strategy Pattern
date: '2013-08-03T22:48:00.001-07:00'
author: aml
tags:
- apprenticeship
modified_time: '2013-08-19T20:09:42.227-07:00'
thumbnail: http://1.bp.blogspot.com/-P1xyfnDav8M/Uf3puC1X2YI/AAAAAAAAAJo/JJ4tkNo58ZY/s72-c/generic.jpg
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5770468443598190590
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/template-pattern-vs-strategy-pattern.html
---

Uncle Bob touches on the Template and Strategy Patterns in <i><a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" target="_blank">PPP</a></i>. I thought it might be personally beneficial to discuss some of the pros and cons of each approach here.<br /><br /><b>Template Pattern</b><br /><b><br /></b><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-P1xyfnDav8M/Uf3puC1X2YI/AAAAAAAAAJo/JJ4tkNo58ZY/s1600/generic.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://1.bp.blogspot.com/-P1xyfnDav8M/Uf3puC1X2YI/AAAAAAAAAJo/JJ4tkNo58ZY/s320/generic.jpg" width="177" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">It's beer! We don't know what kind until we mark it up and slap a label on it.<br /><a href="http://www.savingadvice.com/articles/2008/08/26/102270_generic-food.html" target="_blank">Image from www.savingadvice.com</a></td></tr></tbody></table><b><br /></b>This pattern is pretty simple. It relies on inheritance. You have some algorithm that you need to use in multiple places. Instead of violating the DRY principle, you can extract the generics of that algorithm into a template class and change the specifics in a subclass. I don't have any examples of the Template Pattern in any code that I'm working on now, so I'll come up with a simple example.<br /><br /><br /><pre class="brush:ruby">class WashDishes<br /><br />  def wash<br />    while !@dishes_done?<br />      wash_dish!<br />    end<br />  end<br /><br />end<br /><br />class DoLaundry<br /><br />  def do<br />    while !@clothes_loaded?<br />      put_article_in_washer!<br />    end<br />  end<br /><br />end<br /><br />class ChoreTemplate<br /><br />  def end_condition_met?<br />  end<br /><br />  def perform_part_of_chore<br />  end<br /><br />  def perform_chore<br />    while !end_condition_met?<br />      perform_part_of_chore<br />    end<br /><br />  end<br />end</pre><br />So at the bottom we have this template that we could inherit from so that we aren't writing the same algorithm over and over again. We just override the details of end_condition_met? and perform_part_of_chore. That's not terrible.<br /><br /><b>Cons</b><br /><br />Uncle Bob mentions that inheritance is a very strong relationship. When you inherit from a class, you are pretty attached to it. In a case like this, I would probably just go for it. I don't see many disadvantages to the Template approach here.<br /><br /><b>Strategy Pattern</b><br /><b><br /></b><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-_6whEjsWGvY/Uf3pREqFilI/AAAAAAAAAJg/zX8-gfRh8iA/s1600/sun+tzu.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://4.bp.blogspot.com/-_6whEjsWGvY/Uf3pREqFilI/AAAAAAAAAJg/zX8-gfRh8iA/s320/sun+tzu.jpg" width="212" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Sun Tzu<br /><a href="http://en.wikipedia.org/wiki/Sun_Tzu" target="_blank">Image from Wikipedia</a></td></tr></tbody></table><b><br /></b><b><br /></b>This pattern is actually pretty cool. Instead of putting the generic algorithm into some template or abstract class, we actually place it in a concrete class. This concrete class' implementation relies on an interface that will supply the specifics it needs to execute the algorithm. In the textbook example, this concrete implementation takes an object in its initializer, with the object implementing the interface the class needs, and the class delegating to the expected interface methods. Luckily, I do have a real-world example for this pattern.<br /><br /><br /><pre class="brush:ruby" name="code">#Before Strategy Pattern Refactor<br /><br />class AI<br /><br />  def initialize(token)<br />    @token = token<br />  end<br /><br />  def build_and_return_move_list(board)<br />    move_list = []<br />    possible_moves = board.available_moves<br />    possible_moves.each do |move|<br />      move_score = score_calculator(move,board,@token)<br />      move_list &lt;&lt; [move_score, move]<br />    end<br />    move_list<br />  end<br /><br />  def next_move(board)<br />    MOVE_INDEX = 1<br />    HIGH_SCORE = -1<br />    build_and_return_move_list.sort[HIGH_SCORE][MOVE_INDEX]<br />  end<br /><br />end<br /><br />#After Strategy Pattern Refactor<br /><br />class Minimax <br /><br />  def initialize(token,depth_limit)<br />    @token = token<br />    @depth_limit = depth_limit<br />  end<br /><br />end<br /><br />class AI<br /><br />  def initialize(token, minimax)<br />    @token = token<br />    @minimax = Minimax(@token)<br />  end<br /><br />  def next_move(board)<br />    return @minimax.next_move(board)<br />  end<br /><br />end</pre><br />At the top, we have this minimax algorithm implemented inside of an AI class. But, what if I need to alter the algorithm in some interesting way? I needed to implement an EasyAI class that relied on the same algorithm, just with a different depth limit. Eventually, I decided on implementing the algorithm in a concrete class.<br /><br />The concrete Minimax class expects to be instantiated with a token and depth limit. This is the interface it relies on. Notice that my example differs slightly from the textbook example in that I don't pass in the interface-implementing object directly. This is due partly to the fact that unit-testing is a lot easier without passing in objects.<br /><br /><b>Cons</b><br /><b><br /></b>There's more code involved with implementing the Strategy Pattern. In a statically-typed language, you need to code up the interface that the concrete algorithm class can rely on. This pattern also seems a bit counter-intuitive to me. One of the first things you learn about OOP is that objects and classes usually model some physical counterpart. An algorithm isn't really a physical thing, and it feels a tad strange to approach a problem like this. Not that it's a bad thing, I just think it takes a while to wrap your head around.<br /><br /><b>Summary</b><br /><b><br /></b>I'm going to go with the Strategy Pattern over the Template Pattern whenever possible. There's this really interesting idea that <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank">composition should always be preferred to inheritance</a>. While I think that's a bit extreme, I prefer the idea of encapsulating some generic behavior in a class and obtaining our desired behavior by changing what we pass in to that class, rather than implementing subclasses for every specific situation.<br /><br />One thing worth noting is that the normal Strategy Pattern would require a new interface implementation for every situation. This is why I actually prefer my use of the Strategy Pattern over the more textbook example. It relies on the token and depth_limit variables that I can just pass in. I don't need to implement a MediumAI subclass to change the Minimax class' behavior; I can just alter the depth_limit parameter. This simplifies things quite a bit and definitely makes it easier to test.
