---
layout: article
title: Where Do Bug Fixes Go?
date: '2013-08-06T17:57:00.002-07:00'
author: aml
tags: 
modified_time: '2013-08-11T17:56:26.102-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-2071585389154853624
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/where-do-bug-fixes-go.html
---

I discovered a bug in my Tic Tac Toe application today that's becoming quite a nuisance. I have this AI class with a "next_move" method. Can you guess what it does? Well, this class works quite well with a completely empty board or a partially filled board. Problem is, I never implemented a smart check against a board that was completely full or a board that already had a winner. So, what happens is that it'll keep giving you moves even if you give it a full board.<br /><br /><b>Possible Fixes</b><br /><b><br /></b>There are a few possible fixes and I'm not exactly sure which one to go for.<br /><br />On one hand, I could add more unit tests that check for these boundary conditions and fix the bug. This would be good because I wouldn't have to worry about this kind of thing in the future.<br /><br />On the other hand, fixing the bug could cause huge problems in the client code that already depends on the AI class. But, the client code is structured in such a way that this kind of problem would never arise. The AI class would never get its hands on a board where the game's over; the game would just stop running. I think this was my rationale for not checking this boundary condition sooner. &nbsp;And fixing the bug now may cause ripples throughout the application. With this in mind, I could just alter the client code I plan to write in order to accommodate this sort of thing.<br /><br /><b>Question</b><br /><b><br /></b>This actually brings up an interesting question. How do you decide around boundary cases like this? Should you ensure that the client API is never abused? We shouldn't give our AI class a board if we don't really want anything back. Or should you make it so that the API is resilient to abuse? We may pass in a bad board by accident. It's reasonable to expect no move back.<br /><br /><b>Decision</b><br /><b><br /></b>Blogging about the problem actually clarifies it a bit. Even if existing client code is structured in such a way that it won't trigger the bug, it's still a good idea to fix it. That way, future calls to the AI class won't need to worry about any non-sensical behavior; making a move on a full board doesn't make much sense. But, I don't think this debate is over.<br /><br />Link to AI class:<br />https://github.com/arlandism/tic_tac_toe/blob/master/game/ai.py<br /><br />
