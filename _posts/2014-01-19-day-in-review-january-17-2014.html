---
layout: post
title: Day In Review - January 17, 2014
date: '2014-01-19T11:46:00.002-08:00'
author: aml
tags: 
modified_time: '2014-01-19T11:46:20.281-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-2548245598553831309
blogger_orig_url: https://immutablearlandis.blogspot.com/2014/01/day-in-review-january-17-2014.html
---

In my <a href="http://immutablearlandis.blogspot.com/2014/01/day-in-review-11614.html" target="_blank">last post</a>, I mentioned trying to construct a function that would generate a graph of relationships. After getting more familiar with the code, this turned out to be a fairly straightforward problem to deal with. But, now a new problem has arisen.<div><br /></div><div>There's one client for whom all of this data is generated. Before, this client would query the root node of the graph for all of its data. This node would in turn query its children and the children would query their children until eventually all of the necessary data had been generated, with a database query happening at each node in the graph. The catch is, before being passed up to a parent node, this "raw" database data would undergo some transformation.</div><div>&nbsp;</div><div>Now, this client gets all of the "raw" data from one database query. Borrowing from the example in my last post, let's talk in terms of the "city" structure.&nbsp;</div><div><br /></div><div>Let's assume this is the structure that we want:</div><div>"</div><div>(def city-id 3)</div><div>(get-info-for-city city-id) =&gt;</div><div>{:streets [{:name "Milwaukee" :houses [{:address "321 Foo" :residents [{:name "Tom"}]}]}]}&nbsp;</div><div>"</div><div><br /></div><div>but this is the structure that we're getting:</div><div>"</div><div><div>(def city-id 3)</div><div>(get-info-for-city city-id) =&gt;</div><div>{:streets [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{:name "Milwaukee" :db-key 72 :condition "subpar"&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:houses [{:address "321 Foo" :db-key 829 :mailbox false</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :residents [{:name "Tom" :db-key 736 :occupation "boxer"}]}]}]}&nbsp;</div></div><div>"</div><div><br /></div><div>The question now becomes "How does the data get structured?" After discussing it with Wai Lee, my decision was to pass the data down from the top to get it structured by each node in the hierarchy, with each node delegating to another "formatting" function for its children. In the above example, we'd hand all of the streets to a function, say "format-street", which would remove the db-key and condition from the street and call a function, "format-house" on each house, etc. This would result in data that's formatted and ready for the top-level consumer.&nbsp;</div><div><br /></div><div>The drawback with this approach is the transitive dependency from the top-level consumer to the lower-tier formatting functions. Though, I think this was a problem in the original code as well, with the only difference being that now data is being passed down and up again, versus just being passed up.</div>