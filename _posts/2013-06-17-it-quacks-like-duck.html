---
layout: post
title: It Quacks Like a Duck
date: '2013-06-17T19:47:00.002-07:00'
author: aml
tags: 
modified_time: '2013-06-18T13:01:38.080-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-429966633484466946
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/06/it-quacks-like-duck.html
---

<span style="font-family: Times, Times New Roman, serif;">Today, while meditating on Uncle Bob's wisdom about OOD, I found myself googling the definition of "duck-typing". From Wikpedia, "duck typing is a style of dynamic typing in which an object's methods and properties determine the valid semantics...". This is a fancy way of saying that you don't have to verify an object is a duck before calling it's quack method.</span><br /><br /><span style="font-family: Times, Times New Roman, serif;">In languages like Java, everything is enforced and statically typed. Good OOD would dictate declaring some sort of inheritance structure for classes with similar methods or creating an interface that each similar class implements. This is different in duck-typing languages. I honestly prefer the former since it makes you think harder about the classes you use and the interfaces you define.</span><br /><span style="font-family: Times, Times New Roman, serif;"><br /></span><br /><pre class="brush:python" name="code"><br />class Duck(object):<br />  <br />    def quack(self):<br />        print "Quack!"<br /><br />class Jedi(object):<br /><br />    def quack(self):<br />        print "May the Quack be with you!"<br /><br />class Quacker(object):<br />    def __init__(self,object_to_quack):<br />        self.object_to_quack = object_to_quack<br /><br />    def make_it_quack(self):<br />        self.object_to_quack.quack()<br /><br />duck = Duck()<br />obi = Jedi()<br />quacker_one = Quacker(duck)<br />quacker_one.make_it_quack()<br />>>> "Quack!"<br />quacker_two = Quacker(obi)<br />quacker_two.make_it_quack()<br />>>> "May the Quack be with you!"<br /></pre>Cool, eh? I can use my Quacker to access anything with a quack method. This is sometimes good, great even, but can be dangerous. What if we had a certain class that we want to operate only on certain objects. We can't guarantee that the object we pass in is what we expect. As long as it has a quack method it'll work just fine. Continuing the above concept: <pre class="brush:python" name="code"><br /><br />class DuckSounds(object):<br />    def __init__(self,duck):<br />        self.duck = duck<br /><br />    def make_duck_sound(self):<br />        self.duck.quack()<br /><br />class Sith(Jedi):<br /><br />    def quack(self):<br />        print "Come to the Quack side!"<br /></pre> In the above example, we clearly expect a duck to be passed in, but there's nothing stopping that nasty Sith from  getting passed in and destroying the delicate balance of the Quack! You may ask yourself why in the world you would  pass in a Sith object if you know that you're expecting a duck. You wouldn't! At least not intentionally. But I'm  finding that the more you work with higher-level abstractions, the more small nuances like that become harder to track and manage. Plus, you can override native method functionality in your objects, meaning things like "+" and "hash[key]" don't just work on numbers and hashes, respectively. Obviously, you expect DuckSounds to take a duck, but somewhere in your code or your tests you may have some poorly named variable that doesn't tell you anything about what it does and you test for quack behavior, which it has. But instead of hearing a nice friendly quack you're being enticed to the Quack side. This is unexpected behavior; which is never good.  How can we fix this? One way would be to assert that the object you're using is actually a duck, and not just testing for a quack method. Another would be to not do something as silly as give a Jedi, or Sith, a quack method. The Python community, for instance, emphasizes clean and well-documented code. You shouldn't be doing silly things like that anyway, and if you do, your code should be well-tested and thoroughly explained. But, someone new to Python or new to well-maintained software, like myself, may make novice mistakes that other languages would catch at compile-time.  So, when using a duck-typing language, make sure it's a duck before you try to make_it_quack(). 