---
layout: article
title: Day In Review - January 16, 2014
date: '2014-01-16T10:06:00.000-08:00'
author: aml
tags: 
modified_time: '2014-01-19T10:39:29.924-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-4908446574264964028
blogger_orig_url: https://immutablearlandis.blogspot.com/2014/01/day-in-review-11614.html
---

While working on the functionality mentioned in <a href="http://immutablearlandis.blogspot.com/2014/01/keeping-things-dry.html" target="_blank">this post</a>, I was tasked with adding a function to the wrapper's API for a very specific use-case.<br /><br />There's a route in the app that, when called, will generate a JSON graph structure with a big relationship tree. Let's use a city example: cities have streets, which have houses, which have residents.<br /><br />{:city [:street-one :street-two]<br />&nbsp; :street-one [:house-one]<br />&nbsp; :street-two [:house-two]<br />&nbsp; :house-one [:resident-one]<br />&nbsp; :house-two []}<br /><br />So, a call to "/city" generates a response that creates that searches the database for this entire relationship. Our current implementation walks the tree and generates each node's underlying nodes (get all the streets in the city of "Chicago" and for each street get all the houses, etc.) using separate database queries for each new relationship.<br /><br />Because of our recent switch to Korma we have the ability to get all of the relevant nodes in one query and that's what I started working on today. I think I have the specific query nailed down, but I still need to get used to the nuances of table relationships to be sure I understand how things work.<br /><br />Korma's API has a "with" macro defined that allows you to target associated child nodes. I started playing with that functionality today and got a "no relationship defined for table: street". Initially, I thought this was weird because I was under the assumption that the relationships between these tables had already been established and that all I had to do was write a new query. After some digging, I found that relationships were defined via IDs and we'd just search all the relevant tables looking for selections matching a parent node's ID, but there was no explicit declaration of a "has_many" relationship between a parent node and child node.<br /><br />So, that tree-walking I mentioned earlier was happening like: get all the streets with a "city-id" matching the "Chicago" ID and for each street get every house with a "street-id" matching that street's ID, etc.<br /><br />Korma's API lets you write the equivalent Clojure code:<br /><br />"<br />(select city<br />&nbsp; (with street<br />&nbsp; &nbsp; (with house<br />&nbsp; &nbsp; &nbsp; (with resident)))<br />&nbsp; &nbsp;(where {:name "Chicago"}))<br />"<br /><br />This does all of the heavy-lifting for us, which ends up making a lot of the code written prior unnecessary since a lot of it was dedicated to this specific use-case. With that in mind, there'll be lots of trimming and refactoring that needs to be done. This story is turning out to be a lot more involved than I initially thought.
