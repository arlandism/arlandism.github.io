---
layout: article
title: Day's Challenges
date: '2013-09-10T19:00:00.001-07:00'
author: aml
tags: 
modified_time: '2013-09-10T19:11:18.433-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-123872724774631602
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/days-challenges.html
---

Today, I did more work on my feature. At first, I struggled with deciding how to proceed. I didn't know whether I should keep test-driving the class I wrote yesterday or try another approach.<br /><br />I decided to write high-level tests in the application's spec file. The first thing I did was assert that moves and a winner were being written to a file. I got the tests passing, extracted to a method and then extracted to a class. At this point, I stubbed the class out in the application's spec file and moved the test down to the "describe 'integration'" block.<br /><br />My next move was to start giving this extracted class some more behavior. This was the tough part. First, I had to choose a file format. In some of my previous feature work I opted for YAML, but my mentor mentioned that my current application already heavily utilizes JSON. So this time I went straight for JSON.<br /><br />Next, I had to figure out a good testing strategy; I didn't like the idea of writing to and reading from files for every test. I revisited a great article from Josh Cheek on <a href="http://blog.8thlight.com/josh-cheek/2011/10/01/testing-code-thats-hard-to-test.html" target="_blank">testing things that are hard to test</a>, and another he wrote on <a href="http://blog.8thlight.com/josh-cheek/2011/11/28/three-reasons-to-roll-your-own-mocks.html" target="_blank">hand-rolling your own mocks</a>. I'm no stranger to writing my own mocks, but Rspec is so powerful that I choose not to. In this case, I decided to give it a shot to see how it would work. I was pleased! The test reads much better than it would with a bunch of stubs and "should_receive"s. The mock implemented an IO interface along with an internal store of what was written to it, along with a "has_content?" method so I could use Rspec's "should have_content" assertions.<br /><br />Now I had to choose how to represent the data. Immediately, I came up with the idea of having a structure like so:<br /><br /><pre class="brush:ruby">game = {<br />  "moves" =&gt; <br />    [<br />      {1 =&gt; "x"}, {2 =&gt; "o"}, {4 =&gt; "x"], {5 =&gt; "o"}, {7 =&gt; "x"}<br />    ]<br />  "winner" =&gt; "x"<br />}<br /></pre><br />But, I can't figure out a good way to append new moves to this data structure. Alternatively, my mentor mentioned representing the data like this:<br /><br /><br /><pre class="brush:ruby">game = {<br />  "moves" =&gt; <br />    [<br />      {"position" =&gt; 1, "token" =&gt; "x"}<br />    ]<br />}<br /></pre><br />So, I'm currently trying to figure out the best way to represent the data. After that, I'll be working on the parsing and figuring out how to represent unique games.
