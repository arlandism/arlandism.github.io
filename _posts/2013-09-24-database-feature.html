---
layout: article
title: Database Feature
date: '2013-09-24T14:51:00.001-07:00'
author: aml
tags:
- apprenticeship 
modified_time: '2013-09-24T14:51:24.316-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1519753405879943226
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/database-feature.html
---

I'm working on integrating my game histories with Postgres.<br /><br /><b>Overview</b> <br /><br />Conceptually, databases seem to work just like web servers. You spin them up and they wait for connecting "clients". When a client connects, the database server spawns a new process to speak to the newly-connected client. After this point, the database server no longer speaks to the client connection - the client has its own mediator that can speak to it and the database. The original server program functions only as a runner and dispatcher. It delegates all communication efforts to its mediators.<br /><br /><b>First Hurdle</b><br /><br />Figuring out a representation of the game history data. I've never had to reason about my data structures in a database-friendly way. The first structure that comes to mind is very similar to the JSON structure, where I have a "games" table that has an i.d., a winner and a set of moves. Here's where it gets confusing: the moves attribute of the "games" table would need a foreign-key relationship with a separate "move" table since, conceptually, a move has attributes associated with it. It looks like this in Ruby code:<br /><br /><b> </b><br /><b> </b><br /><pre class="brush:ruby" name="code">games = {<br />  "id" =&gt; {<br />    "moves" =&gt; [{"position" =&gt; 3, "token" =&gt; "x"}],<br />    "winner" =&gt; "x"<br />   }<br />}<br /></pre><br />Given this object-oriented schema, the idea that each move has its own data jumps out at you. What's interesting is that when my mentor initially suggested this schema I was hesitant to adopt it; I didn't like the idea of representing each individual move as a hash. But, this structure makes the data much easier to reason about.<br /><br />Edit:<br />It turns out that the ORM I'm using, DataMapper, takes care of the underlying schema for me so I can just write "models" in Ruby code.<br /><br /><b>Second Hurdle</b><br /><br />Right now, it's pretty cheap computationally to update the file storage system every time a move is made. Database access doesn't have that same luxury. So, my next objective is to figure out when to write games to the database. For now, I'm going to operate under the naive assumption that the user doesn't care about speed and update the database after every move.&nbsp;<b> </b><br /><br /><b>Day Summary</b><br /><br />The database has been configured and now I'm working on the client side - the Sinatra application. I managed to apply some <a href="http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html" target="_blank">wisdom from Eric Smith</a> in today's workflow when I created a wrapper around the access point to the database.<b> </b><br /><br />
