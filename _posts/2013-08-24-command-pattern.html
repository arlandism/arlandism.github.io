---
layout: post
title: Command Pattern
date: '2013-08-24T16:20:00.002-07:00'
author: aml
tags: 
modified_time: '2013-08-26T07:29:54.985-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-1281375129946497627
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/command-pattern.html
---

In preparation for an upcoming presentation I'll be giving on the Command Pattern, I'd like to outline a few of the key points about the pattern here.<br /><br /><b>Overview</b><br /><b><br /></b>The Command Pattern is a technique for encapsulating method calls. It sounds odd, I know. You're essentially creating a wrapper around one or more method calls. Although simple, the Command Pattern is extremely useful for separating logic concerns, delaying execution, and implementing undo functionality.<br /><br /><b>Primary Usage</b><br /><b><br /></b>The Command Pattern is most frequently used for abstracting logical concerns. We could have these three classes:<br /><br /><br /><pre class="brush:ruby" name="code">class Car<br /><br />  def start_ignition<br />    @ignition.start<br />  end<br /><br />  def shift(mode)<br />    @gear_shift.shift(mode)<br />  end<br /><br />end<br /><br />class Bike<br /><br />  def start_pedaling<br />    @rider.begin<br />  end<br /><br />end<br /><br />class VehicleStarter<br /><br />  def start_vehicle(vehicle)<br />    #Set vehicle in motion<br />  end<br /><br />end<br /></pre><br />Imagine we need to implement that "start_vehicle" functionality. We want our "VehicleStarter" class to be able to start vehicles, but in the above scenario it would need to know HOW to start vehicles, instead of being able to just start them. Instead of putting that logic in the VehicleStarter we can encapsulate it into a command.<br /><br /><br /><pre class="brush:ruby" name="code"># The interface isn't really necessary. It's just for illustrative purposes<br />class CommandInterface<br /><br />  def initialize(vehicle)<br />    @vehicle = vehicle<br />  end<br /><br />  def start<br />  end<br /><br /><br />end<br /><br />class StartBike &lt; CommandInterface<br /><br />  def start<br />    @vehicle.start_pedaling<br />  end<br /><br />end<br /><br />class StartCar &lt; CommandInterface<br /><br /><br />  def start<br />    @vehicle.start_ignition<br />    @vehicle.shift("drive")<br />  end<br /><br />end<br /></pre><br />Now, our VehicleStarter class can just focus on starting the vehicles, not needing to know HOW they're started.<br /><br /><b>Pros</b><br /><b><br /></b>Indeed, there is a logical separation here and a clear separation of responsibilities. The code is very SRP-compliant.<br /><br /><b>Cons</b><br /><br />There's only a very thin veil around the "start" implementation. Arguably, we introduced a lot of unnecessary complexity by encapsulating those method calls into classes. On the other hand, my example classes were small. Imagine if there was a lot more that needed to be done before "starting". Our example could possibly be extended to anything with an engine. We could have a "LawnMower" class that needs to be filled with gasoline, primed, and then started. it would be very burdensome to have all that logic coupled together in the VehicleStarter class.<br /><br /><b>Summary</b><br /><b><br /></b>The Command Pattern, while simple, is useful. This was only one example of its implementation; and this example was somewhat trivial.<br /><br />One thing worth mentioning is that, in my examples, there's really no need to define a Command interface, or even a separate Command class. Both the "Bike" and the "Car" could've defined their own "start" methods that did everything we needed. In real-life, something like my example would probably be used if you were relying on some third-party code or API that you didn't have access to or didn't want to modify.