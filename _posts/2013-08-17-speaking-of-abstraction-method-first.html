---
layout: article
title: 'Speaking of Abstraction: Method First, Class Second'
date: '2013-08-17T16:11:00.003-07:00'
author: aml
tags: 
modified_time: '2013-08-17T16:11:42.083-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-958689457145312283
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/speaking-of-abstraction-method-first.html
---

Yesterday, I learned some interesting lessons from my mentor. We talked about refactoring and what approaches to take when you're stuck. I've found that I usually get stuck during refactors because of something in my code that's overly complex.<br /><br />For instance, I have this "Responder" class that takes in some data through this "transmitter" object, prepares a response, and then hands the response off to the "transmitter".  <br /><br /><br /><pre class="brush:python" name="code">class Responder(object):<br />  <br />    def __init__(self,transmitter,generator=None):<br />        if generator is None:  generator = MoveGenerator()<br />        self.transmitter = transmitter<br />        self.generator = generator<br /><br />    def respond(self):<br />        transmitter_data = self.transmitter.receive()<br />        comp_move = self.ai_move(transmitter_data)<br />        winner = self.generator.winner()<br />        self.transmitter.send(comp_move)<br />        self.transmitter.send(winner)<br /><br />    def ai_move(self, board_state):<br />        move_from_generator = self.generator.next_move(board_state)<br />        return move_from_generator<br /></pre><br />When I wrote this class, I only needed it to send back one "kind" of thing - information about the next move. Now, I'm finding that I need this class to receive some configuration information, handle that, and then send off the next move.<br /><br /><b>data -&gt; do stuff with it -&gt; send stuff back</b><br /><br />So, there should be one problem with this approach that leaps out at you. Why does the Responder know what kind of data it's receiving and how to prepare a response? Well, for the first use case this approach was fine and it worked well. To introduce a layer of abstraction at that point would've smelled of needless complexity. It's an easy fix now though, right? What do you think?<br /><br /><b>Refactoring&nbsp;</b><br /><b><br /></b>My first thought is to introduce a new class that knows how to prepare the responses. It can figure out what goes where and leave the actual sending of the response to the Responder. There's a lot going on in this "respond" method though. I'm not sure how the new class should work. Do we just call it twice? Wait, the comp_move variable has to be sent before the winner variable. The Responder can't know the order because that would imply that it knows the contents. But, if it calls the ResponseHandler twice, won't that imply that it knows there are two messages?<br /><br />Ok, let's stop here. I came down this slippery-slope purposefully to illustrate a practical concept I learned from my mentor: Whenever possible, you should extract methods before you extract classes. What does this mean?<br /><br /><br /><pre class="brush:python" name="code">class Responder(object):<br /><br />    def __init__(self,transmitter,generator=None):<br />        if generator is None:<br />            generator = MoveGenerator()<br />        self.transmitter = transmitter<br />        self.generator = generator<br /><br />    def respond(self):<br />        transmitter_data = self.transmitter.receive()<br />        response = self.__response(transmitter_data)<br />        self.transmitter.send(response)<br /><br />    def __response(self, data):<br />        move_from_generator = self.generator.next_move(board_state)<br />        winner = self.generator.winner()<br />        response = {"move":move_from_generator,<br />                    "winner": winner}<br />        return response<br /><br /></pre><br />That looks a lot cleaner. It's pretty obvious now what needs to be done.<br /><br /><br /><pre class="brush:python" name="code">class Responder(object):<br /><br />    def __init__(self,transmitter,builder=None):<br />        if builder is None:<br />            builder = ResponseBuilder()<br />        self.transmitter = transmitter<br />        self.builder = builder<br /><br />    def respond(self):<br />        transmitter_data = self.transmitter.receive()<br />        response = self.builder.response(transmitter_data)<br />        self.transmitter.send(response)<br /><br /><br />class ResponseBuilder(object):<br /><br />    def __init__(self,generator=None):<br />        if generator is None:<br />            generator = MoveGenerator()<br />        self.generator = generator<br /><br />    def response(self, data):<br />        move_from_generator = self.generator.next_move(board_state)<br />        winner = self.generator.winner()<br />        response = {"move":move_from_generator,<br />                    "winner": winner}<br />        return response</pre><br />What made the new class so hard to build initially was the fact that we weren't sure what we were building. By extracting those ugly details from the "respond" method into a private method, we could easily see what needed to be abstracted out of the class. All the extra stuff that was going on wasn't part of the API so the new method was obviously private. But, that lead us to a private method that knew too much about things that weren't its own. This lead to a clear division of responsibility between the Responder and the new ResponseBuilder.<br /><br /><b>Alternatives/Drawbacks</b><br /><br />My mentor mentioned that the Responder class now has almost too little responsibility. I argued that without the Responder class, the ResponseBuilder would need to know how to send messages and prepare them. That leads back to the same kind of class we started with. He has a bit of a point though. It's essentially just the middleman between the ResponseBuilder and the transmitter.<br /><br />Another thing worth noting is that the ResponseBuilder class could get awfully big if it has to handle more logic. If it comes to that, I think I may have the ResponseBuilder hold an array of everything that needs to touch the response and pass the response around like a message. To do that now would be premature though.<br /><br /><b>Summary</b><br /><b><br /></b>Abstracting complexity into a method should always occur before abstracting complexity into a class. Otherwise, you risk mis-creating the new class and not having a clear abstraction. Pushing the complexity down to a private method first gives more clues about whether or not the class should really be handling that responsibility.
