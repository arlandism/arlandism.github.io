---
layout: post
title: Are My Tests Worth It? - Part II
date: '2013-12-04T20:10:00.002-08:00'
author: aml
tags: 
modified_time: '2013-12-04T20:13:13.003-08:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-2571938049968412051
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/12/are-my-tests-worth-it-part-ii.html
---

Yesterday, I blogged about an <a href="http://immutablearlandis.blogspot.com/2013/12/are-my-tests-worth-it.html" target="_blank">interesting test situation</a> I was in. The tests my teammate and I were writing seemed to be very repetitive, which led me to the conclusion that they may not be worth writing. I think that something's off if you don't even have to think about the test you're writing. What I wasn't sure of was what these tests were telling me. The answer came to me today while working on a different function in the same namespace.<br /><br />There was a new function we wanted to write: "set-new-response". It would persist a given widget's response. We started writing a test and it looked eerily similar to the tests we were writing yesterday. I could tell it was going down the same path so I decided to think harder about the problem. I then realized that our code was too knowledgeable - it knew about every kind of widget! Not only did this force us to write ugly tests, it would make it harder to add new widgets in the future. So, what if we wrote tests that made no assumptions about the kinds of widgets we had? What if we wrote really dumb tests? And we did!<br /><br />"<br />(describe 'set-new-response'<br />&nbsp; (it 'persists widget responses'<br />&nbsp; &nbsp; (set-new-response {:widget :my-widget :response "foo" :timeout 200})<br />&nbsp; &nbsp; (should= "foo" (last-response-for :my-widget))))<br />"<br /><br />This test takes a map with an arbitrary widget name, but somehow it persists that widget's response. This was the implication we were looking for. We wanted to know that we could persist data and return it when queried. Our first solution cared too much about what those queries would look like. Recall from the test code I posted yesterday that the tests were redefining the values of atoms living inside the production namespace. This should've been an immediate red flag since it coupled the tests to the storage implementation.<br /><br /><b>Yesterday's Problems</b><br /><b><br /></b>I told Phil that we should start over and write new tests, without concerning ourselves with how the implementation would look. I've noticed that having what you "think" is a good implementation in mind pushes your tests toward relying on that implementation. Here's a sample of one of our new tests:<br /><br />"<br />(describe 'hit-api?'<br />&nbsp; (it 'returns true if the timeout has expired'<br />&nbsp; &nbsp; &nbsp;(with-redefs [current-time (fn [_] 200)]<br />&nbsp; &nbsp; &nbsp; &nbsp;(set-new-response {:widget :my-widget :response "response" :timeout 300}))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(with-redefs [current-time (fn [_] 500)]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(should= true (hit-api? :my-widget)))))<br />"<br />After the work we did on "set-new-response", I was confident that we should change "hit-api?" to a similar implementation. Once again, I realized we had been too stuck on how we thought the implementation should look.<br /><br /><b>Summary</b><br /><br />I think this is a problem that really highlights the benefits of TDD. The tests were a clear indication that something was wrong with the original implementation. By taking a step back and really letting our "stupid" tests ask us questions we were able to work towards a solution that we were happy with.