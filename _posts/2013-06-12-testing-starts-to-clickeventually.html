---
layout: post
title: Testing Starts To Click....Eventually
date: '2013-06-12T12:19:00.000-07:00'
author: aml
tags: 
modified_time: '2013-06-12T13:29:34.158-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-3520000345246938388
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/06/testing-starts-to-clickeventually.html
---

I was having a really difficult time understanding testing, and how it should be implemented. After hacking away on my own projects for so long it's hard to familiarize myself with all of these new software development principles (i.e the Single Responsibility Principle, decoupling, abstraction, etc.). Encountering new principles like these really accentuates the difference between me and my self-taught programming versus someone with a more traditional background. But, I see a bright flicker of hope at the end of the unfamiliar tunnel.<br /><br />&nbsp;For me, testing really started to sink in when I viewed my system from an unfamiliar point of view. It's good to try to imagine your software from the perspective of someone else that may want to use it. Even if your modules aren't actually meant to standalone, in most cases they should be fairly independent (at least the classes in them). I've found that I rely too much on dependencies, and really take things for granted. For instance, my tic tac toe program relies heavily on user input. So, I didn't think that I'd be able to test it well since I would have to input manually every time I wanted to run my tests. In my last post, I naively pointed out a flawed solution that I had come up. With the prodding of my mentor and peers, I've been able to construct a much better solution.<br /><br />&nbsp;My test code now relies heavily on mocks. For those unfamiliar with the concept, as I was two days ago, mocking is a way of imitating your production code's dependencies. For instance, I need input from the user and I'm relying on Python's built-in methods to handle the standard input stream and get the input for me. This doesn't make for very easy testing. But, if I create a Mock object with an API similar to that of Python's built-in stdin components then I can use that in my test code.<br /><br />Here's an example of a mock object in Python: <br /><div><pre class="brush:python" name="code">class MockUserInput(object):<br /><br />    def __init__(self,vals):<br />        self.data = list(vals)<br />        self.times_called = 0<br /><br />    def output(self):<br />        self.__increment_times_called__()<br />        print self.data<br />        return self.data.pop(0)<br /><br />    def __increment_times_called__(self):<br />        self.times_called += 1<br /></pre></div><br />How is this useful? Glad you asked! So now when I'm testing I can supply MockUserInput as a parameter so that the object I'm initializing calls the mock object's input. Afterwards, I can access the mock object's self.times_called parameter to make sure that it was called like I expected. The real user input class is an extremely simple class that just has an output method that calls Python's standard input handler. Here's the code for an example test:<br /><br /><pre class="brush:python" name="code">class GameClassTests(unittest.TestCase):<br />    def test_that_player_one_moves(self):<br />        fake_player_one = MockPlayer("x",MockUserInput([1,2,3]))<br />        fake_player_two = MockPlayer("o",MockUserInput([4,5,6]))<br />        game = Game(fake_player_one,fake_player_two)<br />        game.run()<br />        self.assertTrue(fake_player_one.input_method.times_called &gt;= 1)<br /></pre><br />So in this example, I know that an input method was called and I can just substitute in my actual PlayerInput class in the production code.