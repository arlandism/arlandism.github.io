---
layout: post
title: Effective Input Testing
date: '2013-06-10T14:15:00.000-07:00'
author: aml
tags: 
modified_time: '2013-06-12T13:30:42.320-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-468923902211670824
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/06/effective-input-testing.html
---

While working on the Game class of my tic tac toe, I found it difficult to test drive the central engine. Mainly because I kept thinking about the games in terms of what input the game engine would collect from the user. After some careful prodding, my mentor led me to the realization that the game engine should be decoupled from collecting user input, and that this would make it easier to test.<br /><br />Here's an example of how I envisioned the game class:<br /><br /><pre class="brush: python">class Game(object):<br /><br />    def run(self):<br />        player_one = "x"<br />        move = raw_input("Please select a move: ")<br />        game.move(move,player_one)<br /></pre><br />As you can tell it's pretty difficult to test that the move selected will actually work as intended without<br />running the test suite and manually inputting moves.<br /><br />What I ended up doing was creating two classes: PlayerInput and FakePlayerInput<br />Since the classes are so similar I could test the FakePlayerInput class and just substitute the PlayerInput class into the production code. They're intentionally kept very small and simple so that it's an easy substitution and nothing unexpected happens.<br /><br /><pre class="brush: python">import random<br /><br />class FakePlayerInput(object):<br /><br />    def output(self,board):<br />        int_list = board.available_moves()<br />        return random.choice(int_list)<br /><br /><br />class PlayerInput(object):<br /><br />    def output(self,board):<br />        available_moves = board.available_moves()<br />        space = 0<br />        while space not in available_moves:<br />            print available_moves<br />            space = int(raw_input("Where would you like to move: "))<br />        return space<br /></pre><br /><div>Then I created a player class that took an input method in its initializer to tell it where it should be getting its input.<br /><br /></div><div><pre class="brush:python">import playerinput<br /><br />class Player(object):<br /><br />    PLAYERS_DICT = {'x':'o','o':'x'}<br /><br />    def __init__(self,token,input_method=playerinput.PlayerInput()):<br />        self.token = token<br />        self.opponent_token = (self.PLAYERS_DICT[token])<br />        self.input_method = input_method<br />                <br />    def next_move(self,board):<br />        return self.input_method.output(board)<br /></pre><br /></div><div><br /></div><div>After setting this up, I was able to effectively test FakePlayerInput and later substitute in PlayerInput to the Player constructor. Going through this taught me a lot about abstraction and how important it is. My mentor mentioned that the Game class should follow the SRP (Single Responsibility Principle) and that it shouldn't care where the players were getting their input. It's only job should be to manage the game and make moves as specified. After implementing these changes, I was able to test-drive the Game class and complete a production version of it.</div>