---
layout: article
title: File Pointer Gotchas
date: '2013-09-13T17:46:00.000-07:00'
author: aml
tags: 
modified_time: '2013-09-13T17:46:21.719-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-4162457320649664088
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/09/file-pointer-gotchas.html
---

So, in my last post I talked about how awesome it was to handroll my own mock and have tests that I could understand without relying on too much RSpec magic. Well, that mock actually came back to bite me, hard!<br /><br />I was trying to mock out a file and simulate what would actually happen when reading to and writing from a file. Basically, I would "write" to my mock like so:<br /><br /><pre class="brush:ruby" name="code">it "writes to a file" do<br />  MyClass.write_to_file("stuff",mock_file)<br />  mock_file.should have_content("stuff")<br />end<br /></pre><br />I was using an array to store what was being appended to the mock. The mock's "has_content?" method just made a check against that array. Eventually, my tests built up to a point where I was reading complicated data structures from the "file", doing some stuff to those data structures and then writing the result of that computation back to the file. My goal was to overwrite the content that already existed in the file with the newly-computed data. This worked out really well for testing purposes and seemed to be guiding my implementation in the right direction.<br /><br />Sweet, all of my Rspec tests pass. Let's run the integration tests. Awesome, they're all green. Let's check the real file to see if stuff actually got written the way we expected it to be written. Nope!<br /><br />I spent a lot of time trying to figure out what was broken. The high confidence that I had in my tests floundered. I changed around the mock, hoping that it would expose some tiny detail I was missing. I didn't discover anything.<br /><br />After talking with my mentor, I learned a lot more about the problem. Let's say we open a file like so:<br /><br /><pre class="brush:ruby" name="code">f = File.open("my_file.txt","r")<br />content = f.read</pre><br />This gives us the content of the file, as you would expect. What I thought was that I could now overwrite what was in the file like this: <br /><br /><pre class="brush:ruby" name="code">f = File.open("my_file.txt", "r+")<br />content = f.read<br />new_content = compute_some_stuff(content)<br />f.write(new_content)<br />f.close<br /></pre><br /><br />That didn't quite work the way I expected it to; instead of overwriting the file, it was actually appending to it. So, what really happens is that when you open a file with File.open, the mode that you give it determines where Ruby will put the pointer - the thing that reads the contents of memory. In our example, that pointer was being placed at the beginning of the file, which is what we want. But, in order to read the contents that already lived in that file, the pointer had to traverse over the memory blocks, leaving it at the end of the file after the reading was done. The real solution to what I was trying to accomplish looks something like this: <br /><br /><pre class="brush:ruby" name="code">f = File.open("my_file.txt","r")<br />contents = f.read<br />f.close<br />new_contents = compute_some_stuff(contents)<br />f = File.open("my_file.txt","w")<br />f.write(new_contents)<br />f.close<br /></pre><br /><br />Here, we close the file after reading it and then open it again to write to it. This resets the file pointer. We can simplify this code dramatically by utilizing other methods of the File interface. <br /><br /><pre class="brush:ruby" name="code">contents = File.read("my_file.txt")<br />new_contents = compute_some_stuff(contents)<br />File.write("my_file.txt",new_contents)</pre><br />Cool, Ruby can close the file for us behind the scenes.<br /><br /><b>Summary</b><br /><b><br /></b>Abstractions suck sometimes when you don't know how things are really working underneath them.
