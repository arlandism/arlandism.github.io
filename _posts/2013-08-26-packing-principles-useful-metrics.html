---
layout: post
title: Packing Principles - Useful Metrics
date: '2013-08-26T20:39:00.001-07:00'
author: aml
tags: 
modified_time: '2013-08-27T13:56:07.288-07:00'
blogger_id: tag:blogger.com,1999:blog-1730093662423317857.post-5356656569301070133
blogger_orig_url: https://immutablearlandis.blogspot.com/2013/08/packing-principles-useful-metrics.html
---

It took a while, but I finally got through the Principles of Package Design chapter of <i>PPP</i>. Glancing through the chapter, I was sure that this would be one of those chapters that I wish I could skip. Now that I've finished it, I feel like I really took something out of it. I'd like to share some of what I learned here.<br /><br /><b>Packaging Metrics</b><br /><b><br /></b>I like math, so it was cool to read about the metrics for good packaging.<br /><br /><ul><li><b>Stability - </b>Stability can be summarized as reasons not to change. Stable packages have little to no dependencies, with many dependents. Each of a package's dependents can be thought of as another reason not to change. Stable packages usually represent the high-level design of a system - i.e. the part least likely to change often. To get an accurate metric of how stable a package is we can use the formula: <i>I</i> = C<sub>e</sub>/ C<sub>a</sub> + C<sub>e</sub> where C<sub>e</sub> is the number of classes inside the package that depend on classes in external packages, C<sub>a</sub> is the number of classes in external packages that depend on classes inside the package and <i>I</i> is the instability of the package. <i>I </i>can range from 0 to 1 (inclusive), with 0 being a perfectly stable package and 1 being a completely unstable package. While mathematical metrics are useful, real-life results rarely correspond precisely to their mathematical counterparts. Most packages lie somewhere between 0 and 1, but many could still be considered good packages. Optimal systems have <i>I </i>measurements that get closer to 0 as you traverse the dependency arrows towards the low-level packages.</li></ul><ul><li><b>Abstraction - </b>Abstraction is expressed as the ratio of abstract classes in a package to the total number of classes in that package ( A = N<sub>a</sub>/N<sub>c</sub>). In dynamic languages, this could probably be measured by counting the number of parent classes (assuming an inheritance hierarchy) or counting the number of shared method families between classes (three different kinds of Employee classes all implementing pay_rate and id_number could be counted as one abstraction). A measure of 1 indicates that a package contains only abstract classes.&nbsp;</li></ul><ul><li><b>Main Sequence - </b>This is the linear relationship established between stability and abstraction. The line runs from (1, 0) to (0, 1). Anything on, or near, this line is in good shape. To calculate a package's position on the line, use its stability measure as its x-coordinate and its abstraction measure as its y-coordinate.&nbsp;</li></ul><ul><li><b>Normalized Distance - </b>A useful way of determining how far a package is from the main sequence. The formula is D' = |A + <i>I</i>&nbsp;- 1|. A value of 0 means that the package falls somewhere on the line. A value of 1 means that the package is as far away as it can get.</li></ul><div>All sorts of fancy things can be done with this kind of data. UB goes on to talk about some statistical analysis and time variables. It's a pretty interesting read.</div>